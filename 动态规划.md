# 动态规划

## 定义

动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理，**把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划**。

## 基本特点

1. 最优子结构，当前一个状态得到最佳解时，当前状态在前一个状态下一定有最优解；
1. 子问题重叠，每个状态下要解决的问题除参数不同外，其本质是一样的；
1. 有边界，当解决了最后一个子问题时，整个问题得解；
1. 子问题独立，解决一个子问题时，不依赖于另一个同级的子问题，只与它的母问题有关。

## 例题

### 爬楼梯

> 有一个十阶楼梯，每次只能走一阶或两阶，那么从一阶到十阶共有几种走法。

分析:

1. 如果要到十阶，那么出发点只能是八阶或九阶(一次走一到两阶);
2. 假设从一阶走到八阶的方法有 x 种，那么从八阶到十阶的走法也是 x 种(因为八阶到十阶是一次跨两步，所以八阶到十阶的方法无非就是在一到八阶的后面多了一个固定的走两阶步骤); 同理从九阶走到十阶的方法有 y 种；
3. 所以走到十阶的方法有 F(10) = F(9) + F(8) 种；
4. 同理 F(9) = F(8) + F(7)
5. 边界条件是 第一阶 和 第二阶(至少要有两个数才能推第三个数)

```javascript
// 回调法 时间复杂度 O(2^n)，空间复杂度 O(1)
function dp(n) {
  if (n <= 0) return 0
  if (n === 1) return 1
  if (n === 2) return 2

  return dp(n - 1) + dp(n - 2)
}

// 优化
// 因为有一些数据被重复计算, 比如计算F(10) = F(9) + F(8); F(8) = F(7) + F(6), 此时只需要把计算过的数据存储一遍就行了。
// 时间复杂度 O(n)，空间复杂度 O(n)
let obj = {}
function dp(n) {
  if (n <= 0) return 0
  if (n === 1) return 1
  if (n === 2) return 2
  
  if (obj[n]) return obj[n]
  
  let val = dp(n - 1) + dp(n-2)
  obj[n] = val
  return val
}

// 逆向递推法 时间复杂度 O(n), 空间复杂度 O(1)
function dp(n) {
	function dp(n) {
  if (n <= 0) return 0
  if (n === 1) return 1
  if (n === 2) return 2

  let x = 1, y = 2, temp = 0

  for (let i = 3; i <= 10; i++) {
    temp = x + y
    x = y
    y = temp
  }

  return temp
}
```


