# MIDDLE

## 2. 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

Example:

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

> 思路：额，莽就是了。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    int tmp = 0;
    ListNode result = null, rHead = new ListNode(0);
    while (l1 != null || l2 != null) {
      int t = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + tmp;
      tmp = t / 10;
      if (result == null) {
        result = new ListNode(t % 10);
        rHead = result;
      } else {
        result.next = new ListNode(t % 10);
        result = result.next;
      }
      if (l1 != null)
        l1 = l1.next;
      if (l2 != null)
        l2 = l2.next;
    }
    if (tmp == 1) {
      result.next = new ListNode(tmp);
    }
    return rHead;
  }
}
```

## 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

Example:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

> 思路：
> 1. 我的思路
>   1) 设置 map，存储元素；
>   2) 遍历元素，如果该元素出现过，那么找到之前的这个元素, 清空map，重新记录；
>   3) 从这个元素的下一个开始重新计算。
> 
> 2. 大神的思路
>   1) 设置 map，存储元素的索引；设置计算长度的起始点；
>   2) 如果该元素出现过，那么，对比该元素之前的索引与现在的起点大小，如 之前索引 小于 现在起点，那么意味着 之前索引 到 目前索引肯定存在重复值，所以选择较大的那个，为了排除这个重复值，需要将索引 +1；
>   3) 计算当前索引到起点的长度与最大长度作对比
>   4) 存储/更新当前元素的索引。

```java
class Solution {
  public static int lengthOfLongestSubstring(String s) {
    int max = 0, start = 0;
    Map<Character, Integer> obj = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
      char t = s.charAt(i);
      if (obj.containsKey(t))
        start = Math.max(start, obj.get(t) + 1);
      max = Math.max(max, i - start + 1);
      obj.put(t, i);
    }
    return max;
  }
}
```

## 5. 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

Example:

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

> 思路：
> 1. 以当前元素为中心，和以当前元素和下一个元素为中心进行中心扩展。

```java
class Solution {
  public String longestPalindrome(String s) {
    if (s.isEmpty())
      return "";
    int idx = 0, left = 0, right = 0;
    String result = "";
    while (idx < s.length()) {
      int current = Math.max(handler(s, idx - 1, idx + 1), handler(s, idx, idx + 1));
      if (current > right - left + 1) {
        left = idx - (int) Math.floor((current - 1) / 2);
        right = idx + (int) Math.floor(current / 2);
      }
      idx++;
    }
    return s.substring(left, right + 1);
  }

  private int handler(String s, int left, int right) {
    while (left >= 0 && right < s.length()) {
      if (s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
      } else {
        break;
      }
    }
    return right - left - 1;
  }
}
```

## 6. Z 字形变换

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

Example:

```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
```

> 思路：对 nusRows * 2 - 2 进行求余。

```java
class Solution {
  public String convert(String s, int numRows) {
    if (s.length() <= 1 || numRows <= 1) return s;

    String[] r = new String[numRows];
    for (int i = 0; i < numRows; i++)
      r[i] = "";
    int p = numRows * 2 - 2;
    for (int i = 0; i < s.length(); i++) {
      int t = i % p;
      r[t < p / 2 ? t : p - t] = r[t < p / 2 ? t : p - t] + s.charAt(i);
    }

    StringBuffer sb = new StringBuffer();
    for (String val : r) {
      sb.append(val);
    }
    return sb.toString();
  }
}
```

## 8. 字符串转换整数 (atoi)

请你来实现一个 parserInt 函数，使其能将字符串转换成整数。

Example:

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

> 思路：计算溢出真恶心

```java
class Solution {
  public int myAtoi(String str) {
    Integer sum = 0;
    Boolean flag = true;
    str = str.trim();
    if (str.length() == 0) return sum;
    
    int i = 0;
    if (str.charAt(0) == '-' || str.charAt(0) == '+') {
      flag = str.charAt(0) == '+';
      i = 1;
    }

    for (; i < str.length(); i++) {
      int tInt = (int)str.charAt(i) - 48;
      if (tInt <= 9 && tInt >= 0) {
        if (flag) {
          if (Integer.MAX_VALUE / 10 < sum ) return Integer.MAX_VALUE;
          else if (Integer.MAX_VALUE / 10 == sum) {
            if (tInt > 7) return Integer.MAX_VALUE;
          }
        } else {
          if (Integer.MIN_VALUE / -10 < sum) return Integer.MIN_VALUE;
          else if (Integer.MIN_VALUE / -10 == sum) {
            if (tInt >= 8) return Integer.MIN_VALUE;
          }
        }
        sum = sum * 10 + tInt;
      } else
        break;
    }
    return flag ? sum : -1 * sum;
  }
}
```

## 11. 盛最多水的容器

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

![](./static/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

> 思路：双指针，取开头和结尾，一步一步向内逼近。

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let l = 0, r = height.length - 1;
  let max = 0;
  while (l < r) {
    let h = Math.min(height[l], height[r]);
    max = Math.max(max, (r - l) * h);
    if (height[l] > height[r]) r--;
    else l++;
  }
  return max;
};
```

## 12. 整数转罗马数字

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

> 思路：做数组将对应的值存储起来，双层循环，从最大的值开始

```javascript
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function (num) {
  let arr_num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];
  let arr_lm = ["I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"];

  let result = "";
  for (let i = arr_lm.length; i >= 0; i--) {
    while (num >= arr_num[i]) {
      num -= arr_num[i];
      result += arr_lm[i];
    }
  }
  return result;
};
```

## 15. 三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

Example:

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

> 思路：
> 1. 对数组进行排序，创建三个指针；
> 2. 以第一个指针为基准开始循环，第二个指针为第一个指针的下一个，第三个指针为数组尾；
> 3. 三个值相加如果等于 0，则push进答案并去重进入下一个循环；如果 大于0，说明第三个指针过大；小于0 说明第二个指针过小；
> 4. 内循环结束后，对外循环去重。

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  let len = nums.length;
  nums = nums.sort((a, b) => a - b);
  if (len <= 2) return [];
  let result = [];
  for (let x = 0; x < len - 2;) {
    for (let y = x + 1, z = len - 1; y < z;) {
      let t = nums[x] + nums[y] + nums[z];
      if (t === 0) {
        result.push([nums[x], nums[y], nums[z]])
        do {
          y++;
        } while (y < z && nums[y] === nums[y - 1]);
        do {
          z--;
        } while (y < z && nums[z] === nums[z + 1]);
      } else if (t > 0) {
        z--;
      } else {
        y++;
      }
    }
    do {
      x++
    } while(x < len - 2 && nums[x] === nums[x - 1]);
  }
  return result;
};
```

## 16. 最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

> 思路：同上一题。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  let len = nums.length;
  if (len <= 2) return [];
  nums = nums.sort((a, b) => a - b);
  let min = nums[0] + nums[1] + nums[2];
  for (let x = 0; x < len - 2;) {
    for (let y = x + 1, z = len - 1; y < z;) {
      let t = nums[x] + nums[y] + nums[z];
      if (Math.abs(t - target) < Math.abs(min - target)) {
        min = t;
      }
      if (t < target) {
        do {
          y++;
        } while(y < z && nums[y] === nums[y - 1])
      } else if (t > target) {
        do {
          z--;
        } while(y < z && nums[z] === nums[z + 1])
      } else {
        return min;
      }
    }
    do {
      x++;
    } while (x < len - 2 && nums[x] === nums[x - 1])
  }
  return min;
};
```

## 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](./static/17_telephone_keypad.png)

> 思路：循环或递归

```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  let dig = {
    "1": [],
    "2": ["a", "b", "c"],
    "3": ["d", "e", "f"],
    "4": ["g", "h", "i"],
    "5": ["j", "k", "l"],
    "6": ["m", "n", "o"],
    "7": ["p", "q", "r", "s"],
    "8": ["t", "u", "v"],
    "9": ["w", "x", "y", "z"]
  }

  let len = digits.length;
  let t = dig[digits[len - 1]] || [];
  for (let i = len - 2; i >= 0; i--) {
    let d = dig[digits[i]];
    let t1 = [];
    for (let dVal of d) {
      for (let tVal of t) {
        t1.push(dVal + tVal);
      }
    }
    t = t1;
  }
  return t;
};
```

## 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

> 思路：四个指针

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  let len = nums.length;
  if (len < 4) return [];
  nums = nums.sort((a, b) => a - b);
  let result = [];
  for (let a = 0; a < len - 3;) {
    for (let b = a + 1; b < len - 2;) {
      for (let c = b + 1, d = len - 1; c < d;) {
        let t = nums[a] + nums[b] + nums[c] + nums[d];
        if (t === target) {
          result.push([nums[a], nums[b], nums[c], nums[d]])
          do {
            c++;
          } while(c < d && nums[c] === nums[c - 1]);
          do {
            d--;
          } while(c < d && nums[d] === nums[d + 1])
        } else if (t > target) {
          d--;
        } else {
          c++;
        }
      }
      do {
        b++;
      } while(b < len - 2 && nums[b] === nums[b - 1])
    }
    do {
      a++;
    } while(a < len - 3 && nums[a] === nums[a - 1])
  }
  return result;
};
```

## 22. 括号生成

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

> 思路：设置左右两个值，左值永远小于等于右值，递归。

```java
class Solution {
  private List<String> result = new ArrayList<>();
  public List<String> generateParenthesis(int n) {
    handler(n, n, "");
    return result;
  }
  private void handler(int l, int r, String s) {
    if (l == 0) {
      while (r-- > 0)
        s += ")";
      result.add(s);
      return;
    }
  
    if (l == r) {
      handler(l - 1, r, s + "(");
    } else if (l < r) {
      handler(l - 1, r, s + "(");
      handler(l, r - 1, s + ")");
    }
  }
}
```

## 24. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

> 思路：定义一个尾节点，在每次交换后，将此次交换后的节点赋值给该节点，下次循环时需要修复下一个值。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p1 = null, p2 = head.next, tmp;
    while (head != null && head.next != null) {
      if (p1 != null)
        p1.next = head.next;
      tmp = head.next.next;
      head.next.next = head;
      head.next = tmp;
      p1 = head;
      head = tmp;
    }
    return p2;
  }
}
```

## 29. 两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

```
输入: dividend = 7, divisor = -3
输出: -2
```

> 思路：
> 1. 使用位运算进行计算可防止超时。 
> 2. 通过将 除数一直乘以2 来逼近被除数，然后 被除数减去这个最大值，继续逼近。
> 3. 由于对 除数右移 有溢出风险，所以选择将被除数左移。

```java
class Solution {
  public int divide(int dividend, int divisor) {
    if (dividend == Integer.MIN_VALUE && divisor == -1)
      return Integer.MAX_VALUE;
    // 用来判断符号是否相异
    Boolean flag = (dividend ^ divisor) >= 0;
    Long dividendLong = Math.abs((long)dividend);
    Long divisorLong = Math.abs((long)divisor);
    int result = 0;
    for (int i = 31; i >= 0; i--) {
      if ((dividendLong >> i) - divisorLong >= 0) {
        result += (1 << i);
        dividendLong -= (divisorLong << i);
      }
    }
    return flag ? result : -result;
  }
}
```

## 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

> 思路：
> 字典序：从右往左，找到第一个左值小于右值的数，然后从右往左，找到第一个大于该左值的数，交换这两个值，并将该左值(不包含)右边的进行从小到大进行排序(原来为降序，只需要改为升序)。

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  let len = nums.length;
  if (len <= 1) return;

  for (let i = len - 2; i >= 0; i--) {
    if (nums[i] < nums[i + 1]) {
      for (let j = len - 1; j > i; j--) {
        if (nums[i] < nums[j]) {
          swap(i, j, nums)
          break;
        }
      }
      let x = i + 1, y = len - 1;
      while (x < y) swap(x++, y--, nums)
      break;
    }
    if (i === 0) {
      let x = i, y = len - 1;
      while (x < y) swap(x++, y--, nums)
    }
  }
};

function swap(i, j, nums) {
  let t = nums[i];
  nums[i] = nums[j];
  nums[j] = t;
}
```

## 33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

> 思路：因为限定 O(log n)，所以使用二分法
> 1. 数组分为两组，那么必定有一组是有序的，判断是否在这个有序的区间内；
> 2. 如果在这个区间，继续二分法直到找到这个值；
> 3. 如果不在这个区间，则将另一个区间继续这样寻找；
> 4. 注意：由于是向下取整，最好先判断右侧是否为有序数组。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  let len = nums.length;
  if (len === 0) return -1;

  return handler(0, len - 1, nums, target);
};

function handler(l, r, nums, target) {
  if (l > r) return -1;
  let mid = (l + r) / 2 | 0;
  if (nums[mid] === target) return mid;
  if (nums[r] > nums[mid]) {
    if (nums[r] >= target && nums[mid] < target)
      return handler(mid + 1, r, nums, target);
    return handler(l, mid - 1, nums, target);
  } else {
    if (nums[l] <= target && nums[mid] > target)
      return handler(l, mid - 1, nums, target);
    return handler(mid + 1, r, nums, target)
  }
}
```

## 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

Example:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

> 思路：二分法
> 1. 先找左边界，从右侧逼近；
> 2. 再找右边界，从左侧逼近，注意：在跳出循环时，会出现两种情况：1. 该值等于target，2. 该值大于target

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  let result = [-1, -1];
  let len = nums.length;
  if (len === 0) return result;
  let l = 0, r = len - 1;
  while (l < r) {
    let mid = (l + r) / 2 | 0;
    if (target <= nums[mid]) r = mid;
    else l = mid + 1
  }
  if (nums[l] !== target) return result;
  result[0] = l;

  r = len - 1;
  while(l < r) {
    let mid = (l + r) / 2 | 0;
    if (target >= nums[mid]) l = mid + 1
    else r = mid;
  }
  if (nums[r] === target) result[1] = r
  else result[1] = r - 1
  return result;
};
```

## 36. 有效的数独

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

![](./static/250px-Sudoku-by-L2G-20050714.svg.png)

> 思路：
> 1. 设置三个数组，分别用于存储行、列、块出现的数字
> 2. 如果该数字曾经出现过则无效。

```java
class Solution {
  public boolean isValidSudoku(char[][] board) {
    boolean[][] rowArr = new boolean[9][9],
            colArr = new boolean[9][9],
            nineArr = new boolean[9][9];
    for (int x = 0; x < 9; x++) {
      for (int y = 0; y < 9; y++) {
        if (board[x][y] != '.') {
          int c = board[x][y] - '1';
          int n = x / 3 * 3 + y / 3;
          if (rowArr[x][c] || colArr[y][c] || nineArr[n][c])
            return false;
          rowArr[x][c] = true;
          colArr[y][c] = true;
          nineArr[n][c] = true;
        }
      }
    }
    return true;
  }
}
```

## 39. 组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

Example:

```
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

> 思路：利用回溯法。如果不满足条件则直接终止。

```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  candidates = candidates.sort((a, b) => a - b);

  let res = [];
  let tmp = [];
  handler(res, tmp, candidates, target, 0);
  return res;
};

function handler(res, tmp, candidates, target, idx) {
  if (target == 0) {
    res.push(tmp);
    return;
  }
  if (target < candidates[idx]) return;
  for (let i = idx; i < candidates.length; i++) {
    let t = [...tmp];
    t.push(candidates[i]);
    handler(res, t, candidates, target - candidates[i], i);
  }
}
```

## 40. 组合总和 II

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。

> 思路：使用回溯法。
> 跳过相同的元素(不包括起始元素)。

```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  let res = [];
  let tmp = [];

  handler(res, tmp, candidates.sort((a, b) => a-b), target, 0);
  return res;
};

function handler(res, tmp, candidates, target, idx) {
  if (target === 0) {
    res.push(tmp);
    return;
  }
  if (idx >= candidates.length || candidates[idx] > target) return;
  for (let i = idx; i < candidates.length; i++) {
    // 重点
    if (i > idx && candidates[i - 1] === candidates[i]) continue;
    let t = [...tmp];
    t.push(candidates[i]);
    handler(res, t, candidates, target - candidates[i], i + 1);
  }
}
```