# MIDDLE

## 2. 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

Example:

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

> 思路：额，莽就是了。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    int tmp = 0;
    ListNode result = null, rHead = new ListNode(0);
    while (l1 != null || l2 != null) {
      int t = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + tmp;
      tmp = t / 10;
      if (result == null) {
        result = new ListNode(t % 10);
        rHead = result;
      } else {
        result.next = new ListNode(t % 10);
        result = result.next;
      }
      if (l1 != null)
        l1 = l1.next;
      if (l2 != null)
        l2 = l2.next;
    }
    if (tmp == 1) {
      result.next = new ListNode(tmp);
    }
    return rHead;
  }
}
```

## 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

Example:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

> 思路：
> 1. 我的思路
>   1) 设置 map，存储元素；
>   2) 遍历元素，如果该元素出现过，那么找到之前的这个元素, 清空map，重新记录；
>   3) 从这个元素的下一个开始重新计算。
> 
> 2. 大神的思路
>   1) 设置 map，存储元素的索引；设置计算长度的起始点；
>   2) 如果该元素出现过，那么，对比该元素之前的索引与现在的起点大小，如 之前索引 小于 现在起点，那么意味着 之前索引 到 目前索引肯定存在重复值，所以选择较大的那个，为了排除这个重复值，需要将索引 +1；
>   3) 计算当前索引到起点的长度与最大长度作对比
>   4) 存储/更新当前元素的索引。

```java
class Solution {
  public static int lengthOfLongestSubstring(String s) {
    int max = 0, start = 0;
    Map<Character, Integer> obj = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
      char t = s.charAt(i);
      if (obj.containsKey(t))
        start = Math.max(start, obj.get(t) + 1);
      max = Math.max(max, i - start + 1);
      obj.put(t, i);
    }
    return max;
  }
}
```

## 5. 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

Example:

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

> 思路：
> 1. 以当前元素为中心，和以当前元素和下一个元素为中心进行中心扩展。

```java
class Solution {
  public String longestPalindrome(String s) {
    if (s.isEmpty())
      return "";
    int idx = 0, left = 0, right = 0;
    String result = "";
    while (idx < s.length()) {
      int current = Math.max(handler(s, idx - 1, idx + 1), handler(s, idx, idx + 1));
      if (current > right - left + 1) {
        left = idx - (int) Math.floor((current - 1) / 2);
        right = idx + (int) Math.floor(current / 2);
      }
      idx++;
    }
    return s.substring(left, right + 1);
  }

  private int handler(String s, int left, int right) {
    while (left >= 0 && right < s.length()) {
      if (s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
      } else {
        break;
      }
    }
    return right - left - 1;
  }
}
```

## 6. Z 字形变换

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

Example:

```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
```

> 思路：对 nusRows * 2 - 2 进行求余。

```java
class Solution {
  public String convert(String s, int numRows) {
    if (s.length() <= 1 || numRows <= 1) return s;

    String[] r = new String[numRows];
    for (int i = 0; i < numRows; i++)
      r[i] = "";
    int p = numRows * 2 - 2;
    for (int i = 0; i < s.length(); i++) {
      int t = i % p;
      r[t < p / 2 ? t : p - t] = r[t < p / 2 ? t : p - t] + s.charAt(i);
    }

    StringBuffer sb = new StringBuffer();
    for (String val : r) {
      sb.append(val);
    }
    return sb.toString();
  }
}
```

## 8. 字符串转换整数 (atoi)

请你来实现一个 parserInt 函数，使其能将字符串转换成整数。

Example:

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

> 思路：计算溢出真恶心

```java
class Solution {
  public int myAtoi(String str) {
    Integer sum = 0;
    Boolean flag = true;
    str = str.trim();
    if (str.length() == 0) return sum;
    
    int i = 0;
    if (str.charAt(0) == '-' || str.charAt(0) == '+') {
      flag = str.charAt(0) == '+';
      i = 1;
    }

    for (; i < str.length(); i++) {
      int tInt = (int)str.charAt(i) - 48;
      if (tInt <= 9 && tInt >= 0) {
        if (flag) {
          if (Integer.MAX_VALUE / 10 < sum ) return Integer.MAX_VALUE;
          else if (Integer.MAX_VALUE / 10 == sum) {
            if (tInt > 7) return Integer.MAX_VALUE;
          }
        } else {
          if (Integer.MIN_VALUE / -10 < sum) return Integer.MIN_VALUE;
          else if (Integer.MIN_VALUE / -10 == sum) {
            if (tInt >= 8) return Integer.MIN_VALUE;
          }
        }
        sum = sum * 10 + tInt;
      } else
        break;
    }
    return flag ? sum : -1 * sum;
  }
}
```

## 11. 盛最多水的容器

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

![](./static/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

> 思路：双指针，取开头和结尾，一步一步向内逼近。

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let l = 0, r = height.length - 1;
  let max = 0;
  while (l < r) {
    let h = Math.min(height[l], height[r]);
    max = Math.max(max, (r - l) * h);
    if (height[l] > height[r]) r--;
    else l++;
  }
  return max;
};
```

## 12. 整数转罗马数字

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

> 思路：做数组将对应的值存储起来，双层循环，从最大的值开始

```javascript
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function (num) {
  let arr_num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];
  let arr_lm = ["I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"];

  let result = "";
  for (let i = arr_lm.length; i >= 0; i--) {
    while (num >= arr_num[i]) {
      num -= arr_num[i];
      result += arr_lm[i];
    }
  }
  return result;
};
```

## 15. 三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

Example:

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

> 思路：
> 1. 对数组进行排序，创建三个指针；
> 2. 以第一个指针为基准开始循环，第二个指针为第一个指针的下一个，第三个指针为数组尾；
> 3. 三个值相加如果等于 0，则push进答案并去重进入下一个循环；如果 大于0，说明第三个指针过大；小于0 说明第二个指针过小；
> 4. 内循环结束后，对外循环去重。

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  let len = nums.length;
  nums = nums.sort((a, b) => a - b);
  if (len <= 2) return [];
  let result = [];
  for (let x = 0; x < len - 2;) {
    for (let y = x + 1, z = len - 1; y < z;) {
      let t = nums[x] + nums[y] + nums[z];
      if (t === 0) {
        result.push([nums[x], nums[y], nums[z]])
        do {
          y++;
        } while (y < z && nums[y] === nums[y - 1]);
        do {
          z--;
        } while (y < z && nums[z] === nums[z + 1]);
      } else if (t > 0) {
        z--;
      } else {
        y++;
      }
    }
    do {
      x++
    } while(x < len - 2 && nums[x] === nums[x - 1]);
  }
  return result;
};
```

## 16. 最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

> 思路：同上一题。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  let len = nums.length;
  if (len <= 2) return [];
  nums = nums.sort((a, b) => a - b);
  let min = nums[0] + nums[1] + nums[2];
  for (let x = 0; x < len - 2;) {
    for (let y = x + 1, z = len - 1; y < z;) {
      let t = nums[x] + nums[y] + nums[z];
      if (Math.abs(t - target) < Math.abs(min - target)) {
        min = t;
      }
      if (t < target) {
        do {
          y++;
        } while(y < z && nums[y] === nums[y - 1])
      } else if (t > target) {
        do {
          z--;
        } while(y < z && nums[z] === nums[z + 1])
      } else {
        return min;
      }
    }
    do {
      x++;
    } while (x < len - 2 && nums[x] === nums[x - 1])
  }
  return min;
};
```

## 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](./static/17_telephone_keypad.png)

> 思路：循环或递归

```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  let dig = {
    "1": [],
    "2": ["a", "b", "c"],
    "3": ["d", "e", "f"],
    "4": ["g", "h", "i"],
    "5": ["j", "k", "l"],
    "6": ["m", "n", "o"],
    "7": ["p", "q", "r", "s"],
    "8": ["t", "u", "v"],
    "9": ["w", "x", "y", "z"]
  }

  let len = digits.length;
  let t = dig[digits[len - 1]] || [];
  for (let i = len - 2; i >= 0; i--) {
    let d = dig[digits[i]];
    let t1 = [];
    for (let dVal of d) {
      for (let tVal of t) {
        t1.push(dVal + tVal);
      }
    }
    t = t1;
  }
  return t;
};
```

## 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

> 思路：四个指针

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  let len = nums.length;
  if (len < 4) return [];
  nums = nums.sort((a, b) => a - b);
  let result = [];
  for (let a = 0; a < len - 3;) {
    for (let b = a + 1; b < len - 2;) {
      for (let c = b + 1, d = len - 1; c < d;) {
        let t = nums[a] + nums[b] + nums[c] + nums[d];
        if (t === target) {
          result.push([nums[a], nums[b], nums[c], nums[d]])
          do {
            c++;
          } while(c < d && nums[c] === nums[c - 1]);
          do {
            d--;
          } while(c < d && nums[d] === nums[d + 1])
        } else if (t > target) {
          d--;
        } else {
          c++;
        }
      }
      do {
        b++;
      } while(b < len - 2 && nums[b] === nums[b - 1])
    }
    do {
      a++;
    } while(a < len - 3 && nums[a] === nums[a - 1])
  }
  return result;
};
```

## 22. 括号生成

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

> 思路：设置左右两个值，左值永远小于等于右值，递归。

```java
class Solution {
  private List<String> result = new ArrayList<>();
  public List<String> generateParenthesis(int n) {
    handler(n, n, "");
    return result;
  }
  private void handler(int l, int r, String s) {
    if (l == 0) {
      while (r-- > 0)
        s += ")";
      result.add(s);
      return;
    }
  
    if (l == r) {
      handler(l - 1, r, s + "(");
    } else if (l < r) {
      handler(l - 1, r, s + "(");
      handler(l, r - 1, s + ")");
    }
  }
}
```

## 24. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

> 思路：定义一个尾节点，在每次交换后，将此次交换后的节点赋值给该节点，下次循环时需要修复下一个值。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p1 = null, p2 = head.next, tmp;
    while (head != null && head.next != null) {
      if (p1 != null)
        p1.next = head.next;
      tmp = head.next.next;
      head.next.next = head;
      head.next = tmp;
      p1 = head;
      head = tmp;
    }
    return p2;
  }
}
```

## 29. 两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

```
输入: dividend = 7, divisor = -3
输出: -2
```

> 思路：
> 1. 使用位运算进行计算可防止超时。 
> 2. 通过将 除数一直乘以2 来逼近被除数，然后 被除数减去这个最大值，继续逼近。
> 3. 由于对 除数右移 有溢出风险，所以选择将被除数左移。

```java
class Solution {
  public int divide(int dividend, int divisor) {
    if (dividend == Integer.MIN_VALUE && divisor == -1)
      return Integer.MAX_VALUE;
    // 用来判断符号是否相异
    Boolean flag = (dividend ^ divisor) >= 0;
    Long dividendLong = Math.abs((long)dividend);
    Long divisorLong = Math.abs((long)divisor);
    int result = 0;
    for (int i = 31; i >= 0; i--) {
      if ((dividendLong >> i) - divisorLong >= 0) {
        result += (1 << i);
        dividendLong -= (divisorLong << i);
      }
    }
    return flag ? result : -result;
  }
}
```
