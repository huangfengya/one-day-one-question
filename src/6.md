## 209. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例：

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

> 思路：滑动窗口法：定义两个指针，左指针用来标示减少，右指针用来表示增加，通过滑动来获取最符合的长度

```javascript
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  let sum = 0, len = nums.length, min = len + 1;
      left = 0;
  for (let i = 0; i < len; i++) {
    sum += nums[i];
    while(sum >= s) {
      min = Math.min(min, i - left + 1);
      sum -= nums[left++]
    }
  }
  return min === len + 1 ? 0 : min;
};
```

## 211. 添加与搜索单词 - 数据结构设计

设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

```
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
```

说明:

你可以假设所有单词都是由小写字母 a-z 组成的。

> 思路：按照长度存储可以防止超时……

```javascript
/**
 * Initialize your data structure here.
 */
var WordDictionary = function() {
  this.obj = {};
};

/**
 * Adds a word into the data structure. 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let len = word.length;
  if (this.obj[len]) this.obj[len].push(word)
  else this.obj[len] = [word]
};

/**
 * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  let arr = this.obj[word.length], len;
  if (arr === undefined || (len = arr.length) < 1)
    return false;
  for (let i = 0; i < len; i++) {
    if (this.diff(arr[i], word)) {
      return true;
    }
  }
  return false;
};

WordDictionary.prototype.diff = function(arrWord, word) {
  for (let i = 0; i < word.length; i++) {
    if (word[i] === ".") continue
    else if (arrWord[i] !== word[i])
      return false;
  }
  return true;
}

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

## 213. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

> 思路：不抢第一个和不抢第最后一个

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let len = nums.length;
  if (len === 0) return 0
  else if (len === 1) return nums

  let tmp1 = [nums[0], Math.max(nums[1], nums[0])], tmp2 = [0, nums[1]]
  for (let i = 2; i < len; i++) {
    tmp1[i] = Math.max(tmp1[i - 2] + nums[i], tmp1[i - 1])
    tmp2[i] = Math.max(tmp2[i - 2] + nums[i], tmp2[i - 1])
  }
  return Math.max(tmp1[len - 2], tmp2[len - 1])
};
```
