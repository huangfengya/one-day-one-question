## 209. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例：

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

> 思路：滑动窗口法：定义两个指针，左指针用来标示减少，右指针用来表示增加，通过滑动来获取最符合的长度

```javascript
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  let sum = 0, len = nums.length, min = len + 1;
      left = 0;
  for (let i = 0; i < len; i++) {
    sum += nums[i];
    while(sum >= s) {
      min = Math.min(min, i - left + 1);
      sum -= nums[left++]
    }
  }
  return min === len + 1 ? 0 : min;
};
```

## 211. 添加与搜索单词 - 数据结构设计

设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

```
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
```

说明:

你可以假设所有单词都是由小写字母 a-z 组成的。

> 思路：按照长度存储可以防止超时……

```javascript
/**
 * Initialize your data structure here.
 */
var WordDictionary = function() {
  this.obj = {};
};

/**
 * Adds a word into the data structure. 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let len = word.length;
  if (this.obj[len]) this.obj[len].push(word)
  else this.obj[len] = [word]
};

/**
 * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  let arr = this.obj[word.length], len;
  if (arr === undefined || (len = arr.length) < 1)
    return false;
  for (let i = 0; i < len; i++) {
    if (this.diff(arr[i], word)) {
      return true;
    }
  }
  return false;
};

WordDictionary.prototype.diff = function(arrWord, word) {
  for (let i = 0; i < word.length; i++) {
    if (word[i] === ".") continue
    else if (arrWord[i] !== word[i])
      return false;
  }
  return true;
}

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

## 213. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

> 思路：不抢第一个和不抢第最后一个

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let len = nums.length;
  if (len === 0) return 0
  else if (len === 1) return nums

  let tmp1 = [nums[0], Math.max(nums[1], nums[0])], tmp2 = [0, nums[1]]
  for (let i = 2; i < len; i++) {
    tmp1[i] = Math.max(tmp1[i - 2] + nums[i], tmp1[i - 1])
    tmp2[i] = Math.max(tmp2[i - 2] + nums[i], tmp2[i - 1])
  }
  return Math.max(tmp1[len - 2], tmp2[len - 1])
};
```

## 215. 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

> 思路：维持一个长度为K的数组，结果即为最后一位的元素

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  let arr = [], j;
  for (let i = 0; i < nums.length; i++) {
    for (j = 0; j < arr.length; j++)
      if (nums[i] >= arr[j])
        break;
    arr.splice(j, 0, nums[i])
    if (arr.length > k) arr.pop();
  }
  return arr.pop()
};
```

## 216. 组合总数 III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

示例 1:

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

> 思路：回溯法，注意剪枝

```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
  let tmp = [], result = [];
  handler(k, result, n, tmp, 1)
  return result;
};

function handler(k, result, target, tmp, curr) {
  if (tmp.length > k) return;
  if (target === 0) {
    if (tmp.length === k)
      result.push([...tmp])
    return;
  }

  for (let i = curr; i <= 9; i++) {
    if (i > target) break;
    tmp.push(i)
    handler(k, result, target - i, tmp, i + 1)
    tmp.pop()
  }
}
```

## 220. 存在重复元素 III

给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

示例 1:

```
输入: nums = [1,2,3,1], k = 3, t = 0
输出: true
```

> 思路：线性扫描

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} t
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, k, t) {
  for (let i = 0; i < nums.length; i++) {
    let n1 = nums[i]
    for (let j = i + 1; j <= i + k && j < nums.length; j++) {
      if (Math.abs(n1 - nums[j]) <= t)
        return true;
    }
  }
  return false;
};
```

## 222. 完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

```
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```

> 思路：递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
  if (root === null) return 0;
  return countNodes(root.left) + countNodes(root.right) + 1
};
```

## 223. 矩形面积

在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。

每个矩形由其左下顶点和右上顶点坐标表示，如图所示。

![](./static/rectangle_area.png)

> 思路：去除共有面积

```javascript
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
  let x1 = C - A, y1 = D - B,
      x2 = G - E, y2 = H - F;
  let I = Math.max(A, E), J = Math.max(B, F),
      K = Math.min(C, G), L = Math.min(D, H);
  let x3 = E >= C || G <= A ? 0 : K - I,
      y3 = F >= D || H <= B ? 0 : L - J;
  return x1 * y1 + x2 * y2 - x3 * y3;
};
```

## 227. 基本计算器 II

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

示例 1:

```
输入: "3+2*2"
输出: 7
```

> 思路：
> 记录上一个运算符，如果为 +/- 则统一为 + 入栈，如果为 *// ，则出栈运算后入栈

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  let stack = [], tmp = 0, sign = "+";
  for (let i = 0; i < s.length; i++) {
    if (/\d/.test(s[i]))
      tmp = tmp * 10 + Number(s[i])
    if (!/\d/.test(s[i]) && s[i] !== " " || i === s.length - 1) {
      if (sign === "+") stack.push(tmp)
      else if (sign === "-") stack.push(-tmp)
      else stack.push(sign === "*" ? stack.pop() * tmp : stack.pop() / tmp | 0)
      sign = s[i]
      tmp = 0
    }
  }
  return stack.reduce((a, b) => a + b)
};
```

## 228. 汇总区间

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

示例 1:

```
输入: [0,1,2,4,5,7]
输出: ["0->2","4->5","7"]
解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。
```

> 思路：注意上一个值与当前值的对比

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
  let result = [], len = nums.length;
  if (len === 0) return result;
  let start = nums[0], prev = nums[0];
  for (let i = 1; i <= len; i++) {
    if (i === len || nums[i] - prev !== 1) {
      if (start === prev) result.push(String(start))
      else result.push(`${start}->${prev}`)
      start = nums[i]
    }
    prev = nums[i]
  }
  return result
};
```

## 229. 求众数 II

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例

```
输入: [3,2,3]
输出: [3]
```

> 思路：摩尔投票法的变种，最多只能出现 2 个超过 n/3 次的数字，不过计算后需要重新验证一下，因为第一遍筛选的只是可能符合结果的值。

```javascript
 /**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  let r1 = 0, r2 = 0,
      n1, n2,
      result = [], len = nums.length
  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) ++r1
    else if (n2 === nums[i]) ++r2
    else if (r1 === 0) n1 = nums[i], r1 = 1  // 注意：这两个判断不能提前，因为可能把x,y赋为同一个值
    else if (r2 === 0) n2 = nums[i], r2 = 1
    else --r1, --r2
  }
  r1 = 0, r2 = 0
  for (let i = 0; i < len; i++) {
    if (nums[i] === n1) ++r1
    else if (nums[i] === n2) ++r2
  }
  if (r1 > len / 3) result.push(n1)
  if (r2 > len / 3) result.push(n2)

  return result;
};
```

## 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

> 思路：
> 方法一：计算左子树节点的个数 n, 如果 n + 1 == k，则输出该节点，如果 n + 1 < k, 则说明在左子树上，否则在右子树上，注意，如果在右子树上的话，节点数需要加上 左子树 + 父节点 的个数。
> 方法二：二叉搜索树的中序遍历即为从小到大，只需要输出第K个数就行。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 方法一：计算左子树数量
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  console.log(handler(root, k, 0))
};

function handler(root, k, curr) {
  let n = nodeNum(root.left);
  if (k > curr + n + 1) {
    return handler(root.right, k, curr + n + 1)
  } else if (k < curr + n + 1) {
    return handler(root.left, k, curr)
  } else {
    return root.val
  }
}

function nodeNum(node) {
  if (node === null) return 0;
  return nodeNum(node.left) + nodeNum(node.right) + 1
}

/**
 * 方法二：中序遍历
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  let result = [], curr = 0;
  while(root !== null || result.length > 0) {
    while (root !== null) {
      result.push(root)
      root = root.left;
    }
    let tmp = result.pop()
    if (++curr === k)
      return tmp.val;
    root = tmp.right;
  }
};
```

## 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![](./static/binarytree.png)

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

> 思路：往底部遍历，遍历到最后一个都含有双方元素的节点

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root === p || root === q || root === null)
    return root
  let t1 = lowestCommonAncestor(root.left, p, q)
  let t2 = lowestCommonAncestor(root.right, p, q)
  if (t1 !== null && t2 !== null)
    return root
  else if (t1 !== null)
    return t1
  else if (t2 !== null)
    return t2
  else
    return null
};
```

## 240. 搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:

```
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

> 思路：可以从右上角开始，如果该值小于 target ，则下移，否则左移

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  let row = matrix.length,
      col = (matrix[0] || []).length;
  let i = 0, j = col - 1;
  while (i < row && j >= 0) {
    let t = matrix[i][j]
    if (t === target) return true
    else if (t > target) j--
    else if (t < target) i++
  }
  return false;
};
```