## 209. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例：

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

> 思路：滑动窗口法：定义两个指针，左指针用来标示减少，右指针用来表示增加，通过滑动来获取最符合的长度

```javascript
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  let sum = 0, len = nums.length, min = len + 1;
      left = 0;
  for (let i = 0; i < len; i++) {
    sum += nums[i];
    while(sum >= s) {
      min = Math.min(min, i - left + 1);
      sum -= nums[left++]
    }
  }
  return min === len + 1 ? 0 : min;
};
```

## 211. 添加与搜索单词 - 数据结构设计

设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

```
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
```

说明:

你可以假设所有单词都是由小写字母 a-z 组成的。

> 思路：按照长度存储可以防止超时……

```javascript
/**
 * Initialize your data structure here.
 */
var WordDictionary = function() {
  this.obj = {};
};

/**
 * Adds a word into the data structure. 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let len = word.length;
  if (this.obj[len]) this.obj[len].push(word)
  else this.obj[len] = [word]
};

/**
 * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  let arr = this.obj[word.length], len;
  if (arr === undefined || (len = arr.length) < 1)
    return false;
  for (let i = 0; i < len; i++) {
    if (this.diff(arr[i], word)) {
      return true;
    }
  }
  return false;
};

WordDictionary.prototype.diff = function(arrWord, word) {
  for (let i = 0; i < word.length; i++) {
    if (word[i] === ".") continue
    else if (arrWord[i] !== word[i])
      return false;
  }
  return true;
}

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

## 213. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

> 思路：不抢第一个和不抢第最后一个

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let len = nums.length;
  if (len === 0) return 0
  else if (len === 1) return nums

  let tmp1 = [nums[0], Math.max(nums[1], nums[0])], tmp2 = [0, nums[1]]
  for (let i = 2; i < len; i++) {
    tmp1[i] = Math.max(tmp1[i - 2] + nums[i], tmp1[i - 1])
    tmp2[i] = Math.max(tmp2[i - 2] + nums[i], tmp2[i - 1])
  }
  return Math.max(tmp1[len - 2], tmp2[len - 1])
};
```

## 215. 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

> 思路：维持一个长度为K的数组，结果即为最后一位的元素

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  let arr = [], j;
  for (let i = 0; i < nums.length; i++) {
    for (j = 0; j < arr.length; j++)
      if (nums[i] >= arr[j])
        break;
    arr.splice(j, 0, nums[i])
    if (arr.length > k) arr.pop();
  }
  return arr.pop()
};
```

## 216. 组合总数 III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

示例 1:

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

> 思路：回溯法，注意剪枝

```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
  let tmp = [], result = [];
  handler(k, result, n, tmp, 1)
  return result;
};

function handler(k, result, target, tmp, curr) {
  if (tmp.length > k) return;
  if (target === 0) {
    if (tmp.length === k)
      result.push([...tmp])
    return;
  }

  for (let i = curr; i <= 9; i++) {
    if (i > target) break;
    tmp.push(i)
    handler(k, result, target - i, tmp, i + 1)
    tmp.pop()
  }
}
```

## 220. 存在重复元素 III

给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

示例 1:

```
输入: nums = [1,2,3,1], k = 3, t = 0
输出: true
```

> 思路：线性扫描

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} t
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, k, t) {
  for (let i = 0; i < nums.length; i++) {
    let n1 = nums[i]
    for (let j = i + 1; j <= i + k && j < nums.length; j++) {
      if (Math.abs(n1 - nums[j]) <= t)
        return true;
    }
  }
  return false;
};
```

## 222. 完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

```
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```

> 思路：递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
  if (root === null) return 0;
  return countNodes(root.left) + countNodes(root.right) + 1
};
```

## 223. 矩形面积

在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。

每个矩形由其左下顶点和右上顶点坐标表示，如图所示。

![](./static/rectangle_area.png)

> 思路：去除共有面积

```javascript
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
  let x1 = C - A, y1 = D - B,
      x2 = G - E, y2 = H - F;
  let I = Math.max(A, E), J = Math.max(B, F),
      K = Math.min(C, G), L = Math.min(D, H);
  let x3 = E >= C || G <= A ? 0 : K - I,
      y3 = F >= D || H <= B ? 0 : L - J;
  return x1 * y1 + x2 * y2 - x3 * y3;
};
```

## 227. 基本计算器 II

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

示例 1:

```
输入: "3+2*2"
输出: 7
```

> 思路：
> 记录上一个运算符，如果为 +/- 则统一为 + 入栈，如果为 *// ，则出栈运算后入栈

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  let stack = [], tmp = 0, sign = "+";
  for (let i = 0; i < s.length; i++) {
    if (/\d/.test(s[i]))
      tmp = tmp * 10 + Number(s[i])
    if (!/\d/.test(s[i]) && s[i] !== " " || i === s.length - 1) {
      if (sign === "+") stack.push(tmp)
      else if (sign === "-") stack.push(-tmp)
      else stack.push(sign === "*" ? stack.pop() * tmp : stack.pop() / tmp | 0)
      sign = s[i]
      tmp = 0
    }
  }
  return stack.reduce((a, b) => a + b)
};
```

## 228. 汇总区间

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

示例 1:

```
输入: [0,1,2,4,5,7]
输出: ["0->2","4->5","7"]
解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。
```

> 思路：注意上一个值与当前值的对比

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
  let result = [], len = nums.length;
  if (len === 0) return result;
  let start = nums[0], prev = nums[0];
  for (let i = 1; i <= len; i++) {
    if (i === len || nums[i] - prev !== 1) {
      if (start === prev) result.push(String(start))
      else result.push(`${start}->${prev}`)
      start = nums[i]
    }
    prev = nums[i]
  }
  return result
};
```

## 229. 求众数 II

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例

```
输入: [3,2,3]
输出: [3]
```

> 思路：摩尔投票法的变种，最多只能出现 2 个超过 n/3 次的数字，不过计算后需要重新验证一下，因为第一遍筛选的只是可能符合结果的值。

```javascript
 /**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  let r1 = 0, r2 = 0,
      n1, n2,
      result = [], len = nums.length
  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) ++r1
    else if (n2 === nums[i]) ++r2
    else if (r1 === 0) n1 = nums[i], r1 = 1  // 注意：这两个判断不能提前，因为可能把x,y赋为同一个值
    else if (r2 === 0) n2 = nums[i], r2 = 1
    else --r1, --r2
  }
  r1 = 0, r2 = 0
  for (let i = 0; i < len; i++) {
    if (nums[i] === n1) ++r1
    else if (nums[i] === n2) ++r2
  }
  if (r1 > len / 3) result.push(n1)
  if (r2 > len / 3) result.push(n2)

  return result;
};
```

## 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

> 思路：
> 方法一：计算左子树节点的个数 n, 如果 n + 1 == k，则输出该节点，如果 n + 1 < k, 则说明在左子树上，否则在右子树上，注意，如果在右子树上的话，节点数需要加上 左子树 + 父节点 的个数。
> 方法二：二叉搜索树的中序遍历即为从小到大，只需要输出第K个数就行。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 方法一：计算左子树数量
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  console.log(handler(root, k, 0))
};

function handler(root, k, curr) {
  let n = nodeNum(root.left);
  if (k > curr + n + 1) {
    return handler(root.right, k, curr + n + 1)
  } else if (k < curr + n + 1) {
    return handler(root.left, k, curr)
  } else {
    return root.val
  }
}

function nodeNum(node) {
  if (node === null) return 0;
  return nodeNum(node.left) + nodeNum(node.right) + 1
}

/**
 * 方法二：中序遍历
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  let result = [], curr = 0;
  while(root !== null || result.length > 0) {
    while (root !== null) {
      result.push(root)
      root = root.left;
    }
    let tmp = result.pop()
    if (++curr === k)
      return tmp.val;
    root = tmp.right;
  }
};
```

## 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![](./static/binarytree.png)

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

> 思路：往底部遍历，遍历到最后一个都含有双方元素的节点

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root === p || root === q || root === null)
    return root
  let t1 = lowestCommonAncestor(root.left, p, q)
  let t2 = lowestCommonAncestor(root.right, p, q)
  if (t1 !== null && t2 !== null)
    return root
  else if (t1 !== null)
    return t1
  else if (t2 !== null)
    return t2
  else
    return null
};
```

## 238. 除自身以外数组的乘积

给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

示例:

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

> 思路：
> 方法一：求一遍左值，求一遍右值，最后相乘
> 方法二：双指针，记录左值和右值，一次遍历求出结果

说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

```javascript
/**
 * 方法一
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  let result1 = [], result2 = [], len = nums.length;
  nums.forEach((_, i) => {
    result1[i] = 1
    result2[i] = 1
  })
  for (let i = 1; i < len; i++) {
    result1[i] = result1[i - 1] * nums[i - 1]
  }

  for (let i = len - 2; i >= 0; i--) {
    result2[i] = result2[i + 1] * nums[i + 1]
  }

  for (let i = 0; i < len; i++) {
    result1[i] *= result2[i]
  }
  return result1;
};

/**
 * 方法二
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  let result = [],
      len = nums.length, left = 1, right = 1;
  nums.forEach((_, i) => {
    result[i] = 1
  })
  for (let i = 0; i < nums.length; i++) {
    result[i] *= left
    left *= nums[i]

    result[len - 1 - i] *= right
    right *= nums[len - 1 - i]
  }
  return result;
};
```

## 240. 搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:

```
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

> 思路：可以从右上角开始，如果该值小于 target ，则下移，否则左移

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  let row = matrix.length,
      col = (matrix[0] || []).length;
  let i = 0, j = col - 1;
  while (i < row && j >= 0) {
    let t = matrix[i][j]
    if (t === target) return true
    else if (t > target) j--
    else if (t < target) i++
  }
  return false;
}
```

## 221. 最大正方形

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

```
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

> 思路：dp，以右下角为基点计算，最大值为 Min（dp[i-1][j-1], dp[i-1][j], dp[i][j-1]）

```java
class Solution {
  public int maximalSquare(char[][] matrix) {
    int row = matrix.length;
    if (row == 0) return 0;
    int col = matrix[0].length, max = 0;
    int[][] tmp = new int[row + 1][col + 1];
    for (int i = 1; i <= row; i++) {
      for (int j = 1; j <= col; j++) {
        if (matrix[i - 1][j - 1] == '1') {
          tmp[i][j] = 1 + Math.min(tmp[i-1][j-1], Math.min(tmp[i-1][j], tmp[i][j-1]));
          max = Math.max(tmp[i][j], max);
        }
      }
    }
    return max * max;
  }
}
```

## 300. 最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

> 思路：需要与前面所有的值进行比较，得出最大值，dp[i] = num[i] > (num[0]~num[i-1]) || max(dp[0]~dp[i-1])，所以动态规划并不仅限于跟前一个值比较，还能跟之前所有值进行比较。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    let len = nums.length, max = 0;
    if (len <= 1) return len;
    let result = [1]
    for (let i = 1; i < len; i++) {
      let tmp = 1;
      for (let j = 0; j < result.length; j++) {
        if (nums[i] > nums[j]) {
          tmp = Math.max(tmp, result[j] + 1)
        }
      }
      result[i] = tmp
      max = Math.max(max, result[i])
    }
    return max
};
```

## 304. 二维区域和检索 - 矩阵不可变

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。

![](./static/304.png)

上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

> 思路：dp，计算每个位置的和，dp[i][j] = dp[i-1][j]+dp[i][j-1]+matrix[i][j]-dp[i-1][j-1]，因为每个位置的值都会相加一个重复值，需要减去该值；结果的值为 (0,0)~(row2,col2) 这块区域的值减去右侧的值减去上侧的值，因为(0,0)~(row1-1,col1-1) 的值被减了两次，需要在加回来一次。

```java
class NumMatrix {
  private int[][] dp;
  public NumMatrix(int[][] matrix) {
    int row = 0, col = 0;
    if ((row = matrix.length) == 0) return;
    if ((col = matrix[0].length) == 0) return;
    dp = new int[row + 1][col + 1];
    for (int i = 1; i <= row; i++) {
      for (int j = 1; j <= col; j++) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];
      }
    }
  }
  
  public int sumRegion(int row1, int col1, int row2, int col2) {
      return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];
  }
}

/**
* Your NumMatrix object will be instantiated and called as such:
* NumMatrix obj = new NumMatrix(matrix);
* int param_1 = obj.sumRegion(row1,col1,row2,col2);
*/
```

## 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例

```
输入: [1,3,4,2,2]
输出: 2
```

说明：

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

> 思路：快慢指针，将其作为一个链表看待，将当前的值作为下次要走到的索引值，因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 00 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。
> 他们相遇的地方不是入口，2(a + b) = a + b + c + b ==> a = c; a: 环前路径，b: 环内已走路径，c: 环内未走路径。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  let slow = nums[0],
      fast = nums[0];
  while (true) {
    slow = nums[slow]
    fast = nums[nums[fast]]
    if (slow === fast) {
      fast = nums[0];
      while (fast !== slow) {
        slow = nums[slow]
        fast = nums[fast]
      }
      return fast
    }
  }
};
```

## 区域和检索-数组可修改

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。

示例:

```
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
```

说明:

- 数组仅可以在 update 函数下进行修改。
- 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

> 思路：动态规划……获取前0~n的和， i ~ n 的和就是 result[n] - result[i - 1]

```javascript
class NumArray {
  /**
   * @param {number[]} nums
   */
  constructor(nums) {
    let len = nums.length;
    this.nums = nums
    let result = [nums[0]]
    for (let i = 1; i < len; i++) {
      result[i] = result[i - 1] + nums[i]
    }
    this.result = result
  }

  /** 
   * @param {number} i 
   * @param {number} val
   * @return {void}
   */
  update(i, val) {
    if (this.nums[i] === val) return;
    let diff = val - this.nums[i]
    this.nums[i] = val
    for (let j = i; j < this.result.length; j++) {
      this.result[j] += diff
    }
  };

  /** 
   * @param {number} i 
   * @param {number} j
   * @return {number}
   */
  sumRange(i, j) {
    return this.result[j] - (i == 0 ? 0 : this.result[i - 1])
  };
}
```

## 309. 最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例：

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

> 思路：
> 如果你手里没有股票，那么有两种可能，你昨天就没有或你卖掉了昨天的：
> dp\[i]\[0] = Max(dp\[i - 1]\[0], dp\[i - 1]\[1] + price\[i])
> 如果你手里有股票，那么也有两种可能，你昨天就有或你前天卖了，今天买了：
> dp\[i]\[1] = Max(dp\[i -1 ]\[1], dp\[i - 2]\[0] - price\[i])

[查看大佬详细解析](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/)

```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let len = prices.length;
  let dp = [];
  for(let _ of prices) dp.push([])
  let dp_i_0 = 0, dp_i_1 = -Infinity, dp_prev_0 = 0

  for (let i = 0; i < len; i++) {
    let tmp = dp_i_0 // 之前手里无股票状态
    // 由于当前状态只于上一个状态有关，可以用常量替代数组
    dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]) // 现在手里无股票状态
    dp_i_1 = Math.max(dp_i_1, dp_prev_0 - prices[i])
    dp_prev_0 = tmp // 上上次手里无股票状态
  }
  return dp_i_0
};
```

## 322. 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

> 思路：实际上也是动态规划，长度是 amount，当前的长度为 min(dp\[i], dp\[i-coin] + 1)

```javascript
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  let dp = []
  for (let i = 0; i <= amount; i++) dp.push(amount + 1)
  dp[0] = 0
  
  for(let i = 0; i <= amount; i++) {
    for (let coin of coins) {
      if (coin <= i) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }
  return dp[amount] >= amount ? -1 :  dp[amount]
};
```

## 324. 摆动排序 II

给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

示例 1:

```
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

> 思路：排序后，分为大小两堆，然后互相穿插值

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var wiggleSort = function(nums) {
  let len = nums.length
  if (len <= 1) return nums
  nums = nums.sort((a, b) => a - b)
  let small = [], big = []
  while (nums.length > 0) {
    small.push(nums.shift())
    if (nums.length === 0) break
    big.unshift(nums.pop())
  }
  while(small.length > 0) {
    nums.push(small.pop())
    if (big.length === 0) break
    nums.push(big.pop())
  }
};
```

## 328. 奇偶链表

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

> 思路：拆分链表，然后组合

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  let odd = new ListNode(null), p1 = odd,
      even = new ListNode(null), p2 = even;
  while (head !== null && head.next !== null) {
    p1.next = head
    p1 = p1.next
    p2.next = p1.next
    p2 = p2.next
    head = p2.next
    p2.next = null
  }
  if (head !== null) {
    p1.next = head
    p1 = p1.next
  }
  p1.next = even.next
  return odd.next
};
```

## 331. 验证二叉树的前序序列化

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

示例 1:

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

> 思路：使用栈，当遇到数字就压入栈，如果遇到 # 就判断栈顶是否为 #，如果是，则证明这个节点是叶子节点，符合前序序列，然后将这个 # 和数字出栈，压入一个 # 代替该节点，如此循环，如果成立的话，最后只会剩一个 #

```javascript
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
  let stack = [], len = -1, pLen = preorder.length
  for (let i = 0; i < pLen; i++) {
    if (preorder[i] === ',') continue
    if (preorder[i] === "#") {
      while(len >= 0 && stack[len] === '#') {
        stack.pop()
        stack.pop()
        len -= 2
      }
      if (len < -1) return false
      stack.push("#")
      len++
    } else {
      while(i < pLen && preorder[i] !== ',') i++
      stack.push("A")
      len++
    }
  }
  return stack.length === 1 && stack[0] === "#"
};
```