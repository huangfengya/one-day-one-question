## 209. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例：

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

> 思路：滑动窗口法：定义两个指针，左指针用来标示减少，右指针用来表示增加，通过滑动来获取最符合的长度

```javascript
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  let sum = 0, len = nums.length, min = len + 1;
      left = 0;
  for (let i = 0; i < len; i++) {
    sum += nums[i];
    while(sum >= s) {
      min = Math.min(min, i - left + 1);
      sum -= nums[left++]
    }
  }
  return min === len + 1 ? 0 : min;
};
```

## 211. 添加与搜索单词 - 数据结构设计

设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

```
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
```

说明:

你可以假设所有单词都是由小写字母 a-z 组成的。

> 思路：按照长度存储可以防止超时……

```javascript
/**
 * Initialize your data structure here.
 */
var WordDictionary = function() {
  this.obj = {};
};

/**
 * Adds a word into the data structure. 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let len = word.length;
  if (this.obj[len]) this.obj[len].push(word)
  else this.obj[len] = [word]
};

/**
 * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  let arr = this.obj[word.length], len;
  if (arr === undefined || (len = arr.length) < 1)
    return false;
  for (let i = 0; i < len; i++) {
    if (this.diff(arr[i], word)) {
      return true;
    }
  }
  return false;
};

WordDictionary.prototype.diff = function(arrWord, word) {
  for (let i = 0; i < word.length; i++) {
    if (word[i] === ".") continue
    else if (arrWord[i] !== word[i])
      return false;
  }
  return true;
}

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */
```

## 213. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

> 思路：不抢第一个和不抢第最后一个

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let len = nums.length;
  if (len === 0) return 0
  else if (len === 1) return nums

  let tmp1 = [nums[0], Math.max(nums[1], nums[0])], tmp2 = [0, nums[1]]
  for (let i = 2; i < len; i++) {
    tmp1[i] = Math.max(tmp1[i - 2] + nums[i], tmp1[i - 1])
    tmp2[i] = Math.max(tmp2[i - 2] + nums[i], tmp2[i - 1])
  }
  return Math.max(tmp1[len - 2], tmp2[len - 1])
};
```

## 215. 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

> 思路：维持一个长度为K的数组，结果即为最后一位的元素

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  let arr = [], j;
  for (let i = 0; i < nums.length; i++) {
    for (j = 0; j < arr.length; j++)
      if (nums[i] >= arr[j])
        break;
    arr.splice(j, 0, nums[i])
    if (arr.length > k) arr.pop();
  }
  return arr.pop()
};
```

## 216. 组合总数 III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

示例 1:

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

> 思路：回溯法，注意剪枝

```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
  let tmp = [], result = [];
  handler(k, result, n, tmp, 1)
  return result;
};

function handler(k, result, target, tmp, curr) {
  if (tmp.length > k) return;
  if (target === 0) {
    if (tmp.length === k)
      result.push([...tmp])
    return;
  }

  for (let i = curr; i <= 9; i++) {
    if (i > target) break;
    tmp.push(i)
    handler(k, result, target - i, tmp, i + 1)
    tmp.pop()
  }
}
```

## 220. 存在重复元素 III

给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

示例 1:

```
输入: nums = [1,2,3,1], k = 3, t = 0
输出: true
```

> 思路：线性扫描

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} t
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, k, t) {
  for (let i = 0; i < nums.length; i++) {
    let n1 = nums[i]
    for (let j = i + 1; j <= i + k && j < nums.length; j++) {
      if (Math.abs(n1 - nums[j]) <= t)
        return true;
    }
  }
  return false;
};
```

## 222. 完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

```
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```

> 思路：递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
  if (root === null) return 0;
  return countNodes(root.left) + countNodes(root.right) + 1
};
```

## 223. 矩形面积

在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。

每个矩形由其左下顶点和右上顶点坐标表示，如图所示。

![](./static/rectangle_area.png)

> 思路：去除共有面积

```javascript
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
  let x1 = C - A, y1 = D - B,
      x2 = G - E, y2 = H - F;
  let I = Math.max(A, E), J = Math.max(B, F),
      K = Math.min(C, G), L = Math.min(D, H);
  let x3 = E >= C || G <= A ? 0 : K - I,
      y3 = F >= D || H <= B ? 0 : L - J;
  return x1 * y1 + x2 * y2 - x3 * y3;
};
```

## 227. 基本计算器 II

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

示例 1:

```
输入: "3+2*2"
输出: 7
```

> 思路：
> 记录上一个运算符，如果为 +/- 则统一为 + 入栈，如果为 *// ，则出栈运算后入栈

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  let stack = [], tmp = 0, sign = "+";
  for (let i = 0; i < s.length; i++) {
    if (/\d/.test(s[i]))
      tmp = tmp * 10 + Number(s[i])
    if (!/\d/.test(s[i]) && s[i] !== " " || i === s.length - 1) {
      if (sign === "+") stack.push(tmp)
      else if (sign === "-") stack.push(-tmp)
      else stack.push(sign === "*" ? stack.pop() * tmp : stack.pop() / tmp | 0)
      sign = s[i]
      tmp = 0
    }
  }
  return stack.reduce((a, b) => a + b)
};
```

## 228. 汇总区间

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

示例 1:

```
输入: [0,1,2,4,5,7]
输出: ["0->2","4->5","7"]
解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。
```

> 思路：注意上一个值与当前值的对比

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
  let result = [], len = nums.length;
  if (len === 0) return result;
  let start = nums[0], prev = nums[0];
  for (let i = 1; i <= len; i++) {
    if (i === len || nums[i] - prev !== 1) {
      if (start === prev) result.push(String(start))
      else result.push(`${start}->${prev}`)
      start = nums[i]
    }
    prev = nums[i]
  }
  return result
};
```

## 229. 求众数 II

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例

```
输入: [3,2,3]
输出: [3]
```

> 思路：摩尔投票法的变种，最多只能出现 2 个超过 n/3 次的数字，不过计算后需要重新验证一下，因为第一遍筛选的只是可能符合结果的值。

```javascript
 /**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  let r1 = 0, r2 = 0,
      n1, n2,
      result = [], len = nums.length
  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) ++r1
    else if (n2 === nums[i]) ++r2
    else if (r1 === 0) n1 = nums[i], r1 = 1  // 注意：这两个判断不能提前，因为可能把x,y赋为同一个值
    else if (r2 === 0) n2 = nums[i], r2 = 1
    else --r1, --r2
  }
  r1 = 0, r2 = 0
  for (let i = 0; i < len; i++) {
    if (nums[i] === n1) ++r1
    else if (nums[i] === n2) ++r2
  }
  if (r1 > len / 3) result.push(n1)
  if (r2 > len / 3) result.push(n2)

  return result;
};
```

## 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

> 思路：
> 方法一：计算左子树节点的个数 n, 如果 n + 1 == k，则输出该节点，如果 n + 1 < k, 则说明在左子树上，否则在右子树上，注意，如果在右子树上的话，节点数需要加上 左子树 + 父节点 的个数。
> 方法二：二叉搜索树的中序遍历即为从小到大，只需要输出第K个数就行。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 方法一：计算左子树数量
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  console.log(handler(root, k, 0))
};

function handler(root, k, curr) {
  let n = nodeNum(root.left);
  if (k > curr + n + 1) {
    return handler(root.right, k, curr + n + 1)
  } else if (k < curr + n + 1) {
    return handler(root.left, k, curr)
  } else {
    return root.val
  }
}

function nodeNum(node) {
  if (node === null) return 0;
  return nodeNum(node.left) + nodeNum(node.right) + 1
}

/**
 * 方法二：中序遍历
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  let result = [], curr = 0;
  while(root !== null || result.length > 0) {
    while (root !== null) {
      result.push(root)
      root = root.left;
    }
    let tmp = result.pop()
    if (++curr === k)
      return tmp.val;
    root = tmp.right;
  }
};
```

## 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![](./static/binarytree.png)

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

> 思路：往底部遍历，遍历到最后一个都含有双方元素的节点

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root === p || root === q || root === null)
    return root
  let t1 = lowestCommonAncestor(root.left, p, q)
  let t2 = lowestCommonAncestor(root.right, p, q)
  if (t1 !== null && t2 !== null)
    return root
  else if (t1 !== null)
    return t1
  else if (t2 !== null)
    return t2
  else
    return null
};
```

## 238. 除自身以外数组的乘积

给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

示例:

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

> 思路：
> 方法一：求一遍左值，求一遍右值，最后相乘
> 方法二：双指针，记录左值和右值，一次遍历求出结果

说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

```javascript
/**
 * 方法一
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  let result1 = [], result2 = [], len = nums.length;
  nums.forEach((_, i) => {
    result1[i] = 1
    result2[i] = 1
  })
  for (let i = 1; i < len; i++) {
    result1[i] = result1[i - 1] * nums[i - 1]
  }

  for (let i = len - 2; i >= 0; i--) {
    result2[i] = result2[i + 1] * nums[i + 1]
  }

  for (let i = 0; i < len; i++) {
    result1[i] *= result2[i]
  }
  return result1;
};

/**
 * 方法二
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  let result = [],
      len = nums.length, left = 1, right = 1;
  nums.forEach((_, i) => {
    result[i] = 1
  })
  for (let i = 0; i < nums.length; i++) {
    result[i] *= left
    left *= nums[i]

    result[len - 1 - i] *= right
    right *= nums[len - 1 - i]
  }
  return result;
};
```

## 240. 搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:

```
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

> 思路：可以从右上角开始，如果该值小于 target ，则下移，否则左移

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  let row = matrix.length,
      col = (matrix[0] || []).length;
  let i = 0, j = col - 1;
  while (i < row && j >= 0) {
    let t = matrix[i][j]
    if (t === target) return true
    else if (t > target) j--
    else if (t < target) i++
  }
  return false;
}
```

## 221. 最大正方形

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

```
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

> 思路：dp，以右下角为基点计算，最大值为 Min（dp[i-1][j-1], dp[i-1][j], dp[i][j-1]）

```java
class Solution {
  public int maximalSquare(char[][] matrix) {
    int row = matrix.length;
    if (row == 0) return 0;
    int col = matrix[0].length, max = 0;
    int[][] tmp = new int[row + 1][col + 1];
    for (int i = 1; i <= row; i++) {
      for (int j = 1; j <= col; j++) {
        if (matrix[i - 1][j - 1] == '1') {
          tmp[i][j] = 1 + Math.min(tmp[i-1][j-1], Math.min(tmp[i-1][j], tmp[i][j-1]));
          max = Math.max(tmp[i][j], max);
        }
      }
    }
    return max * max;
  }
}
```

## 300. 最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

> 思路：需要与前面所有的值进行比较，得出最大值，dp[i] = num[i] > (num[0]~num[i-1]) || max(dp[0]~dp[i-1])，所以动态规划并不仅限于跟前一个值比较，还能跟之前所有值进行比较。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    let len = nums.length, max = 0;
    if (len <= 1) return len;
    let result = [1]
    for (let i = 1; i < len; i++) {
      let tmp = 1;
      for (let j = 0; j < result.length; j++) {
        if (nums[i] > nums[j]) {
          tmp = Math.max(tmp, result[j] + 1)
        }
      }
      result[i] = tmp
      max = Math.max(max, result[i])
    }
    return max
};
```

## 304. 二维区域和检索 - 矩阵不可变

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。

![](./static/304.png)

上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

> 思路：dp，计算每个位置的和，dp[i][j] = dp[i-1][j]+dp[i][j-1]+matrix[i][j]-dp[i-1][j-1]，因为每个位置的值都会相加一个重复值，需要减去该值；结果的值为 (0,0)~(row2,col2) 这块区域的值减去右侧的值减去上侧的值，因为(0,0)~(row1-1,col1-1) 的值被减了两次，需要在加回来一次。

```java
class NumMatrix {
  private int[][] dp;
  public NumMatrix(int[][] matrix) {
    int row = 0, col = 0;
    if ((row = matrix.length) == 0) return;
    if ((col = matrix[0].length) == 0) return;
    dp = new int[row + 1][col + 1];
    for (int i = 1; i <= row; i++) {
      for (int j = 1; j <= col; j++) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];
      }
    }
  }
  
  public int sumRegion(int row1, int col1, int row2, int col2) {
      return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];
  }
}

/**
* Your NumMatrix object will be instantiated and called as such:
* NumMatrix obj = new NumMatrix(matrix);
* int param_1 = obj.sumRegion(row1,col1,row2,col2);
*/
```

## 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例

```
输入: [1,3,4,2,2]
输出: 2
```

说明：

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

> 思路：快慢指针，将其作为一个链表看待，将当前的值作为下次要走到的索引值，因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 00 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。
> 他们相遇的地方不是入口，2(a + b) = a + b + c + b ==> a = c; a: 环前路径，b: 环内已走路径，c: 环内未走路径。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  let slow = nums[0],
      fast = nums[0];
  while (true) {
    slow = nums[slow]
    fast = nums[nums[fast]]
    if (slow === fast) {
      fast = nums[0];
      while (fast !== slow) {
        slow = nums[slow]
        fast = nums[fast]
      }
      return fast
    }
  }
};
```

## 区域和检索-数组可修改

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。

示例:

```
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
```

说明:

- 数组仅可以在 update 函数下进行修改。
- 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

> 思路：动态规划……获取前0~n的和， i ~ n 的和就是 result[n] - result[i - 1]

```javascript
class NumArray {
  /**
   * @param {number[]} nums
   */
  constructor(nums) {
    let len = nums.length;
    this.nums = nums
    let result = [nums[0]]
    for (let i = 1; i < len; i++) {
      result[i] = result[i - 1] + nums[i]
    }
    this.result = result
  }

  /** 
   * @param {number} i 
   * @param {number} val
   * @return {void}
   */
  update(i, val) {
    if (this.nums[i] === val) return;
    let diff = val - this.nums[i]
    this.nums[i] = val
    for (let j = i; j < this.result.length; j++) {
      this.result[j] += diff
    }
  };

  /** 
   * @param {number} i 
   * @param {number} j
   * @return {number}
   */
  sumRange(i, j) {
    return this.result[j] - (i == 0 ? 0 : this.result[i - 1])
  };
}
```

## 309. 最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例：

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

> 思路：
> 如果你手里没有股票，那么有两种可能，你昨天就没有或你卖掉了昨天的：
> dp\[i]\[0] = Max(dp\[i - 1]\[0], dp\[i - 1]\[1] + price\[i])
> 如果你手里有股票，那么也有两种可能，你昨天就有或你前天卖了，今天买了：
> dp\[i]\[1] = Max(dp\[i -1 ]\[1], dp\[i - 2]\[0] - price\[i])

[查看大佬详细解析](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/)

```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let len = prices.length;
  let dp = [];
  for(let _ of prices) dp.push([])
  let dp_i_0 = 0, dp_i_1 = -Infinity, dp_prev_0 = 0

  for (let i = 0; i < len; i++) {
    let tmp = dp_i_0 // 之前手里无股票状态
    // 由于当前状态只于上一个状态有关，可以用常量替代数组
    dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]) // 现在手里无股票状态
    dp_i_1 = Math.max(dp_i_1, dp_prev_0 - prices[i])
    dp_prev_0 = tmp // 上上次手里无股票状态
  }
  return dp_i_0
};
```

## 322. 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

> 思路：实际上也是动态规划，长度是 amount，当前的长度为 min(dp\[i], dp\[i-coin] + 1)

```javascript
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  let dp = []
  for (let i = 0; i <= amount; i++) dp.push(amount + 1)
  dp[0] = 0
  
  for(let i = 0; i <= amount; i++) {
    for (let coin of coins) {
      if (coin <= i) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }
  return dp[amount] >= amount ? -1 :  dp[amount]
};
```

## 324. 摆动排序 II

给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

示例 1:

```
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

> 思路：排序后，分为大小两堆，然后互相穿插值

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var wiggleSort = function(nums) {
  let len = nums.length
  if (len <= 1) return nums
  nums = nums.sort((a, b) => a - b)
  let small = [], big = []
  while (nums.length > 0) {
    small.push(nums.shift())
    if (nums.length === 0) break
    big.unshift(nums.pop())
  }
  while(small.length > 0) {
    nums.push(small.pop())
    if (big.length === 0) break
    nums.push(big.pop())
  }
};
```

## 328. 奇偶链表

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

> 思路：拆分链表，然后组合

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  let odd = new ListNode(null), p1 = odd,
      even = new ListNode(null), p2 = even;
  while (head !== null && head.next !== null) {
    p1.next = head
    p1 = p1.next
    p2.next = p1.next
    p2 = p2.next
    head = p2.next
    p2.next = null
  }
  if (head !== null) {
    p1.next = head
    p1 = p1.next
  }
  p1.next = even.next
  return odd.next
};
```

## 331. 验证二叉树的前序序列化

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

示例 1:

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

> 思路：使用栈，当遇到数字就压入栈，如果遇到 # 就判断栈顶是否为 #，如果是，则证明这个节点是叶子节点，符合前序序列，然后将这个 # 和数字出栈，压入一个 # 代替该节点，如此循环，如果成立的话，最后只会剩一个 #

```javascript
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
  let stack = [], len = -1, pLen = preorder.length
  for (let i = 0; i < pLen; i++) {
    if (preorder[i] === ',') continue
    if (preorder[i] === "#") {
      while(len >= 0 && stack[len] === '#') {
        stack.pop()
        stack.pop()
        len -= 2
      }
      if (len < -1) return false
      stack.push("#")
      len++
    } else {
      while(i < pLen && preorder[i] !== ',') i++
      stack.push("A")
      len++
    }
  }
  return stack.length === 1 && stack[0] === "#"
};
```

## 334. 递增的三元子序列

给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

如果存在这样的 i, j, k,  且满足 0 ≤ i < j < k ≤ n-1，
使得 arr[i] < arr[j] < arr[k] ，返回 true ; 否则返回 false 。
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。

示例 1:

```
输入: [1,2,3,4,5]
输出: true
```

> 思路：
> 方法一：dp，记录当前的比前面大的的个数，下一个值需要与前面的值比较，如果大，那么这个值为 n + 1
> 方法二：设置两个值，维持一个最小值，一个次小值，遇到小的，首先复制给最小的，其次给较大的，否则就成立了：遇到小的进行更新不影响结果，因为前面的成立，则变小后依然成立

```javascript
/**
 * 方法二
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  let max1 = ~(1 << 31), max2 = max1

  for (let val of nums) {
    if (val <= max1) {
      max1 = val
    } else if (val <= max2) {
      max2 = val
    } else {
      return true
    }
  }
  return false
};
```

## 338. 比特位计数

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

```
输入: 2
输出: [0,1,1]
```

> 思路：推荐 方法三
> 方法一：正常计算
> 方法二：规律：2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop count 只相差 1。\[4, 7] 也可以通过上面的规律得到：f(x + b) = f(x) + 1,  b = 2 ^ m
> 方法三：规律，奇数一定比偶数多一位，偶数一定和其一半相等，因为偶数最后一位为 0，除以2等于右移一位

```javascript
/**
 * 方法一
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  let result = []
  for (let i = 0; i <= num; i++)
    result.push(handler(i))
  return result
};

function handler(n) {
  let k = 0;
  while (n !== 0) {
    k++
    n &= (n - 1)
  }
  return k
}

/**
 * 方法二
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  if (num === 0) return [0]
  let result = [0], b = 1;
  for (let i = 1; i <= num;) {
    let j = 0;
    while (j < b && b + j <= num) {
      result[b + j] = result[j] + 1
      j++
    }
    i += b
    b <<= 1
  }
  return result
};

/**
 * 方法三
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  let result = [0]
  if (num === 0) return result
  for (let i = 1; i <= num; i++) {
    if (i % 2 === 1) result[i] = result[i - 1] + 1
    else result[i] = result[i >> 1]
  } 
  return result
};
```

## 341. 扁平化嵌套列表迭代器

给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的项或者为一个整数，或者是另一个列表。

示例 1:

```
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
```

> 思路：妈的，这题有病，真特么难读懂。把数据遍历到数组中……

```javascript
class NestedIterator {
  /**
   * @param {NestedInteger[]} nestedList
   */
  constructor(nestedList) {
    this.tmp = []
    this.index = 0
    this.woca(nestedList)
  }

  /**
   * @param {NestedInteger[]} nestedList
   */
  woca(nestedList) {
    for (let val of nestedList) {
      if (val.isInteger()) {
        this.tmp.push(val.getInteger())
      } else {
        this.woca(val.getList())
      }
    }
  }

  /**
   * @this NestedIterator
   * @returns {boolean}
   */
  hasNext() {
    return this.tmp.length > this.index
  }

  /**
   * @this NestedIterator
   * @returns {integer}
   */
  next() {
    return this.tmp[this.index++]
  }
}
```

## 343. 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

> 思路：动态规划， dp\[i] = max(dp\[i], dp\[i-j] * j, (i - j) * j)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
  let dp = [0, 1]
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j < i; j++) {
      dp[i] = Math.max((i - j) * j, dp[i - j] * j, dp[i] || 0)
    }
  }
  return dp.pop()
};
```

## 347. 前 K 个高频元素

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例 1:

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

> 思路：首先存到 map 中，接下来用 桶排序 或者 堆排序(推荐) 获取前 k 个

```javascript
/**
 * 桶排序
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
  let m = new Map()
  for (let val of nums) m.set(val, m.has(val) ? m.get(val) + 1 : 1)
  let a = []
  m.forEach((val, key) => {
    if (a[val]) a[val].push(key)
    else a[val] = [key]
  })

  let result = []
  for (let i = a.length - 1; i >= 0 && result.length < k; i--) {
    if (!a[i]) continue
    result.push(...a[i])
  }
  return result
};
```

## 365. 水壶问题

有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

你允许：

装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
示例 1: (From the famous "Die Hard" example)

```
输入: x = 3, y = 5, z = 4
输出: True
```

> 思路：ax + by = z。求最大公约数, 令 ax = a * m * g，by = b * n * g，则有 z = (a * m + b * n) * g，有 z % g = 0。最大公约数用辗转相除法计算。感觉有投机取巧之嫌

```javascript
/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {boolean}
 */
var canMeasureWater = function(x, y, z) {
  if (x + y < z) return false
  else if (x + y === z) return true
  return z % gcd(x, y) === 0
};

function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b)
}
```

## 377. 组合总和 Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

> 思路：
> 方法一：dfs 超时了……剪枝后依然超时
> 方法二：dp 比如 \[1,2,3] target = 5,  dp\[5] = dp\[1] + dp\[4], dp\[4] = dp\[1] + dp\[3] 

```javascript
/**
 * 动态规划
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
  if (nums.length === 0) return 0
  let dp = [1]
  for (let i = 1; i <= target; i++) {
    for (let val of nums) {
      if (i >= val)
        dp[i] = (dp[i] || 0) + (dp[i - val] || 0)
    }
  }
  return dp[target] || 0
}

/**
 * dfs（超时）
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
  let result = 0
  handler(target)
  return result

  function handler(target) {
    if (target <= 0) {
      if (target === 0)
        result++
      return
    }
  
    for (let i = 0; i < nums.length; i++) {
      handler(target - nums[i])
    }
  }
};
```

## 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例:

```
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
```

> 思路：使用栈，遇到 ] 则出栈顶，直到遇到 [, [ 的上一个元素则必为要重复的次数，得出结果后入栈

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function(s) {
  let stack = [], tmp = ""
  for (let i = 0; i < s.length; i++) {
    if (/[0-9]/.test(s[i])) {
      if (!/[0-9]/.test(tmp) && tmp !== ''){
        stack.push(tmp)
        tmp = ""
      }
      tmp += s[i]
    } else if (/[a-zA-Z]/.test(s[i])) {
      tmp += s[i]
    } else if (s[i] === '[') {
      stack.push(tmp, '[')
      tmp = ""
    } else {
      let a = tmp, t = ''
      tmp = ''
      do {
        a = t + a
      } while ((t = stack.pop()) !== '[')
      stack.push(a.repeat(+stack.pop()))
    }
  }
  if (tmp !== "") stack.push(tmp)
  return stack.join("")
};
```

## 397. 整数替换

给定一个正整数 n，你可以做如下操作：

1. 如果 n 是偶数，则用 n / 2替换 n。
2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。
n 变为 1 所需的最小替换次数是多少？

示例 1:

```
输入:
8

输出:
3

解释:
8 -> 4 -> 2 -> 1
```

> 思路：主要是对奇数时的 +1/-1，容易看出：如果一个数 /2 后还是偶数，那么次数会少很多。所以遇到奇数时尝试 -1，然后 /2，如果还是奇数，那么说明次数会多很多。另外 3 是个奇葩，需要单独处理，次数为 2

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var integerReplacement = function(n) {
  let k = 0;
  if (n <= 1) return k;
  while (n !== 1) {
    if (n & 1 === 1) {
      if (n === 3) n -= 1
      else if ((n & 3) === 3) n += 1
      else n -= 1
    } else n >>>= 1
    k++
  }
  return k
};
```

## 416. 分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

> 思路：背包问题：能否\[0-i]之间是否存在一个能将背包正好填满的数组，用二维数组解决
> 进阶：因为每次的值都取决于上一次的值，可以简化成一维数组，注意，因为要用到之前的数据而非刚计算的数据需要重后往前算

```javascript
/**
 * 动态规划，二维数组
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  let len = nums.length;
  if (len <= 1) return false
  let sum = nums.reduce((a, b) => a + b)
  if (sum % 2) return false
  
  let mid = sum / 2, dp = []
  for (let i = 0; i < len; i++) {
    if (!dp[i]) dp[i] = []
    for (let j = 0; j <= mid; j++) {
      if (!i) dp[i][j] = j === nums[i]  || j === 0
      else dp[i][j] = dp[i - 1][j] || (j >= nums[i] && dp[i - 1][j - nums[i]])
    }
  }
  return dp[len - 1][mid]
};

/**
 * 一维数组
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  let len = nums.length;
  if (len <= 1) return false
  let sum = nums.reduce((a, b) => a + b)
  if (sum % 2) return false
  
  let mid = sum / 2, dp = []
  for (let i = 0; i <= mid; i++)
    dp[i] = (i === 0 || i === nums[0])

  for (let i = 1; i < len; i++) {
    for (let j = mid; j >= 0; j--) {
      if (j >= nums[i])
        dp[j] = dp[j] || dp[j - nums[i]]
    }
  }
  return dp[mid]
};
```

## 421. 数组中两个数的最大异或值

给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai < 231 。

找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j < n 。

你能在O(n)的时间解决这个问题吗？

示例:

```
输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.
```

> 思路：核心：a ^ b = max 则有 a ^ max = b , b ^ max = a
> 如果要使异或的值最大，则需要高位的 1 越多越好。最高位开始到最低位遍历，首先假设高位是 “1”，把这 n 个数全部遍历一遍，看看这一位是不是真的可以是“1”，否则这一位就得是“0”
> 如果 a ^ b = max 成立 ，max 表示当前得到的“最大值”，那么一定有 max ^ b = a 成立。我们可以先假设当前数位上的值为 “1”，再把当前得到的数与这个 n 个数的 前缀（因为是从高位到低位看，所以称为“前缀”）进行异或运算，放在一个哈希表中，再依次把所有 前缀 与这个假设的“最大值”进行异或以后得到的结果放到哈希表里查询一下，如果查得到，就说明这个数位上可以是“1”，否则就只能是 0

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaximumXOR = function(nums) {
  let result = 0, mask = 0;
  for (let i = 31; i >= 0; i--) {
    mask |= 1 << i
    let set = new Set()
    for (let val of nums) {
      set.add(val & mask)
    }
    let tmp = result | 1 << i // 假装该位置有个 1
    for (let val of set) {
      if (set.has(val ^ tmp)) {
        result = tmp
        break
      }
    }
  }

  return result 
};
```

## 430. 扁平化多级双向链表

您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。

 

示例:

```
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出:
1-2-3-7-8-11-12-9-10-4-5-6-NULL
```

> 思路：本质上就是个递归……注意子项的尾连接到父级的next
> 或者将 next 看做 右节点，child 看做左节点，做先序遍历……

```javascript
/**
 * // Definition for a Node.
 * function Node(val,prev,next,child) {
 *    this.val = val;
 *    this.prev = prev;
 *    this.next = next;
 *    this.child = child;
 * };
 */
/**
 * @param {Node} head
 * @return {Node}
 */
var flatten = function(head) {
  let tmp = head
  while (tmp !== null) {
    if (tmp.child) tmp = handler(tmp)
    tmp = tmp.next
  }
  return head
};

function handler(node) {
  let next = node.next,
      child = node.child;
  node.next = child;
  child.prev = node;
  while(true) {
    if (child.child) {
      child = handler(child)
    }
    if (child.next === null) {
      if (node.child !== null) {
        node.child = null
        child.next = next
        if (next !== null) next.prev = child
      }
      break
    }
    child = child.next
  }

  return child
}
```

## 442. 数组中重复的数据

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

> 思路：因为 1 ≤ a\[i] ≤ n, 以当前值作为索引，将对应的值减去长度，如果下次索引到的值小于等于 0，证明之前索引到过。那么为啥不加长度呢？因为如果值大于 Integer.Max_Value 的一半，值会溢出

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDuplicates = function(nums) {
  let result = [], len = nums.length;
  for (let i = 0; i < len; i++) {
    let tmp = (nums[i] <= 0 ? nums[i] + len : nums[i]) - 1
    if (nums[tmp] <= 0) {
      result.push(tmp + 1)
    } else {
      nums[tmp] -= len
    }
  }
  return result
};
```

## 445. 两数相加 II

给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。

 

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

进阶:

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

示例:

```
输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 8 -> 0 -> 7
```

> 思路：计算出两个链表的长度差，然后按位相加，记录相加后的值大于等于10的总数，然后遍历相加后的链表，如果该位置下一位的数大于10，当前值+1，下一个值取余

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  if (l1 === null) return l1
  else if (l2 === null) return l2
  let l1Len = 0, l2Len = 0, two = 0;
  let tmpL1 = l1, tmpL2 = l2;
  while(tmpL1 !== null) l1Len++, tmpL1 = tmpL1.next;
  while(tmpL2 !== null) l2Len++, tmpL2 = tmpL2.next;
  let diff = l1Len - l2Len
  if (diff < 0) {
    diff = l2Len - l1Len
    tmpL1 = l1
    l1 = l2
    l2 = tmpL1
  }
  tmpL1 = l1, tmpL2 = l2
  while (tmpL1 !== null) {
    if (diff-- > 0) {
      tmpL1 = tmpL1.next
      continue
    }
    tmpL1.val += tmpL2.val
    if (tmpL1.val >= 10) two++
    tmpL1 = tmpL1.next
    tmpL2 = tmpL2.next
  }
  let newHead = new ListNode(0)
  newHead.next = l1
  while(two > 0) {
    tmpL1 = newHead
    while(tmpL1.next !== null) {
      if (tmpL1.next.val >= 10) {
        tmpL1.next.val %= 10
        two--
        tmpL1.val += 1
        if (tmpL1.val >= 10)
        two++
      }
      tmpL1 = tmpL1.next
    }
  }
  return newHead.val === 1 ? newHead : newHead.next
};
```

## 450. 删除二叉搜索树中的节点

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。

示例:

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。
```

> 思路：删除其第一个右节点的最后一个左节点，剩下的就是判断了……

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function(root, key) {
  if (root === null) return root
  return handler(root, key, root, null, '')
};

function handler(node, key, head, prev, direction) {
  if (node.val < key) {
    if (node.right === null) return head
    return handler(node.right, key, head, node, 'right')
  } else if (node.val > key) {
    if (node.left === null) return head
    return handler(node.left, key, head, node, 'left')
  } else {
    if (node.left === null && node.right === null) {
      if (prev === null) return null
        prev[direction] = null
      return head
    } else if (node.right === null && prev !== null) {
      prev[direction] = node.left
      return head
    } else {
      if (node.right === null) {
        return node.left
      }
      // 寻找该节点的第一个右节点的最后一个左节点
      let fr = node.right, pl = fr.left, tmpPrev = fr;
      if (pl === null) {
          if (prev !== null)
            prev[direction] = fr
          fr.left = node.left
          return prev === null ? fr : head
      }
      while(pl.left !== null) {
        tmpPrev = pl
        pl = pl.left
      }
      tmpPrev.left = pl.right
      if (prev !== null)
        prev[direction] = pl
      pl.right = node.right
      pl.left = node.left
      return prev === null ? pl : head
    }
  }
}
```

## 451. 根据字符出现频率排序

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例 1:

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

> 思路：map -> array -> 拼接

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var frequencySort = function(s) {
  let m = new Object()
  for (let i = 0; i < s.length; i++) m[s[i]] = (m[s[i]] || 0) + 1
  let tmp = []
  for (let key in m) tmp.push({key, no: m[key]})
  tmp = tmp.sort((a, b) => b.no - a.no)
  let result = ""
  for (let val of tmp) result += val.key.repeat(val.no)

  return result
};
```

## 454. 四数相加 II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

例如:

```
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

> 思路：最容易想到的就是暴力循环了，但是这个会超时，O(n^4)
> 将数组分成两组，分别用 map 记录和的情况，就可以将时间复杂度减少到 O(2(n ^ 2)) 即 O(n ^ 2)

```javascript
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  let obj = new Map(), result = 0
  for (let vi of A) {
    for (let vj of B) {
      obj.set(vi + vj, (obj.get(vi + vj) || 0) + 1)
    }
  }
  for (let vi of C) {
    for (let vj of D) {
      result += (obj.get(-(vi + vj)) || 0)
    }
  }
  return result
};
```

## 456. 132模式

给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:

```
输入: [1, 2, 3, 4]

输出: False

解释: 序列中不存在132模式的子序列。
```

> 思路：
> 方法一：记录所有的 ai < aj 的数组，当出现新值时，与数组内的值进行对比
> 方法二：倒序使用栈记录一个次大的值，如果出现一个大于栈顶的值，那么找出栈中所有小于该值中的最大值，如果出现一个值小于该值，那么成立

```javascript
/**
 * 方法一
 * @param {number[]} nums
 * @return {boolean}
 */
var find132pattern = function(nums) {
  let len = nums.length;
  if (len < 3) return false;
  let max1 = ~(1 << 31), max2 = 1 << 31,
      tmp = [], prevArr = []
  for (let val of nums) {
    if (val <= max1) {
      max1 = val
    } else {
      for (let v of tmp) {
        if (v[0] < val && v[1] > val)
          return true
      }
      if (prevArr[0] === max1) {
        prevArr[1] = Math.max(prevArr[1], val)
      } else {
        tmp.push(prevArr = [max1, max2 = val])
      }
    }
  }
  return false
};

/**
 * 方法二
 * @param {number[]} nums
 * @return {boolean}
 */
var find132pattern = function(nums) {
  let len = nums.length;
  if (len < 3) return false;
  let stack = [], second = 1 << 31
  stack.push(nums[len - 1])
  for (let i = len - 2; i >= 0; i--) {
    if (nums[i] < second) {
      return true
    } else {
      while (stack.length && nums[i] > stack[stack.length - 1]) {
        second = Math.max(second, stack.pop())
      }
      stack.push(nums[i])
    }
  }
  return false
};
```

## 513. 找树左下角的值

给定一个二叉树，在树的最后一行找到最左边的值。

示例:

```
输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7
```

> 思路：记录层数，如果有更深的层，刷新值；而且由于先遍历左子树，再遍历右子树，所以相同层肯定会先输出左边的值，然后同层不覆盖，同层一定是最左边的值

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
  if (root === null) return root
  let maxDeep = 0, maxVal = 0;
  handler(root, 1)
  return maxVal
  
  function handler(node, deep) {
    if (node === null) return
    if (node.left === null) {
      if (deep > maxDeep) {
        maxDeep = deep
        maxVal = node.val
      }
    }
    handler(node.left, deep + 1)
    handler(node.right, deep + 1)
  }
};
```

## 515. 在每个树行中找最大值

您需要在二叉树的每一行中找到最大的值。

示例：

```
输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]
```

> 思路：队列，记录每行的个数

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function(root) {
  if (root === null) return []
  let result = [], num = 1, queue = [root]
  while (queue.length > 0) {
    let tmpNum = 0, max = 1 << 31;
    while (num-- > 0) {
      let node = queue.shift()
      max = Math.max(max, node.val)
      if (node.left !== null) {
        queue.push(node.left)
        tmpNum++
      }
      if (node.right !== null) {
        queue.push(node.right)
        tmpNum++
      }
    }
    num = tmpNum
    result.push(max)
  }
  return result
};
```

## 518. 零钱兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例 1:

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

> 思路：这是个 0-1 完全背包问题
> 状态方程：dp\[i]\[j] = dp\[i - 1]\[j] + dp\[i]\[j - coins\[j]]

```javascript
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
  let result = [1]
  for (let i = 1; i <= amount; i++) result[i] = 0
  for (let i = 0; i < coins.length; i++) {
    let coin = coins[i]
    for (let j = 0; j <= amount; j++) {
      if (j >= coin) {
        result[j] += result[j - coin]
      }
    }
  }
  return result[amount]
};
```

## 523. 连续的子数组和

给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

示例 1:

```
输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。
```

> 思路: 求连续和并且 sum % k = 0，有 (sum\[j] - sum\[i]) % k = 0，有 sum\[j] % k - sum\[i] % k = 0，得出 sum\[j] % k = sum\[i] % k
> 另外：由于至少为 2，为了避免第一个数取余为 0 的情况，所以设置 map<0, -1>

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
  let len = nums.length
  if (len < 2) return false
  let map = new Map(), sum = 0
  map.set(0, -1)
  for (let i = 0; i < len; i++) {
    sum += nums[i]
    if (k !== 0)
      sum %= k
    if (map.has(sum)) {
      if (i - map.get(sum) > 1)
        return true
    } else {
      map.set(sum, i)
    }
  }
  return false
};
```

## 524. 通过删除字母匹配到字典里最长单词

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

示例 1:

```
输入:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

输出: 
"apple"
```

 > 思路：记录字符串字典的位置，遍历字符串，如果字符串的当前字符与字符串字典的当前位置的值相等，则 +1，遍历完成后取出字符串字典中所有被遍历完成的字符串，取出其中最长的。

```javascript
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  let tmp = d.map(() => 0)
  for (let i of s) {
    for (let j = 0; j < tmp.length; j++) {
      if (d[j][tmp[j]] === i) {
        tmp[j] += 1
      }
    }
  }
  let result = [], max = 0;
  for (let i = 0; i < d.length; i++) {
    if (d[i].length === tmp[i] && d[i].length >= max) {
      max = d[i].length
      result.push(d[i])
    }
  }
  
  let tmpResult = []
  for(let i = 0; i < result.length; i++) {
    if (result[i].length === max) {
      tmpResult.push(result[i])
    }
  }
  return tmpResult.sort().shift() || ''
};
```

## 542. 01 矩阵

给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

示例 1:

```
输入:

0 0 0
0 1 0
0 0 0
输出:

0 0 0
0 1 0
0 0 0
```

> 思路：先从左上到右下获取最小值，然后从右下到左上再次获取一次。
> 因为第一次是只能与其左值和上值比较，第二次是下值与右值比较，就能得到正确的值
> 另外：js是大坑，数组一定要先填充，0 和 undefined 都被当成 false 也是个大坑

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
  let row = matrix.length, col = (matrix[0] || []).length;
  let result = []
  // 先填充
  for (let i = 0; i < row; i++) {
    if (!result[i]) result[i] = []
    for (let j = 0; j < col; j++) {
      result[i][j] = ~(1 << 31)
    }
  }
  // 首先确定 0 的位置
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (matrix[i][j] === 0) {
        result[i][j] = 0
      } else { 
        if (i > 0)
          result[i][j] = Math.min(result[i][j], result[i - 1][j] + 1)
        if (j > 0)
          result[i][j] = Math.min(result[i][j], result[i][j - 1] + 1)
      }
    }
  }
  // dp 反向来一遍
   for (let i = row - 1; i >= 0; i--) {
    for (let j = col - 1; j >= 0; j--) {
      if (i < row - 1)
        result[i][j] = Math.min(result[i][j], result[i + 1][j] + 1)
      if (j < col - 1)
        result[i][j] = Math.min(result[i][j], result[i][j + 1] + 1)
    }
  }
  return result
};
```

## 611. 有效三角形的个数

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:

```
输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

> 思路：方法1：暴力循环，时间复杂度 O(n^3)
> 方法2: 先排序，然后只要最小的两个数大于最大的数，则一定能够成立，两个最小的数之间的数也肯定符合,所以可以将复杂度降到 O(n^2)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
  let len = nums.length, result = 0;
  if (len < 3) return 0;
  nums = nums.sort((a, b) => a- b)
  for(let i = len - 1; i >= 2; i--) {
    if (nums[i] === 0) continue
    let k = 0, j = i - 1
    while(k < j) {
      if (nums[k] + nums[j] > nums[i]) {
        result += (j - k)
        j--
      } else {
        k++
      }
    }
  }
  return result
};
```

## 623. 在二叉树中增加一行

给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。

添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。

将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。

如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。

示例 1:

```
输入: 
二叉树如下所示:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

输出: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   
```

> 思路：直接递归到当前行添加就行

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} v
 * @param {number} d
 * @return {TreeNode}
 */
var addOneRow = function(root, v, d) {
  if (d === 1) {
    let node = new TreeNode(v)
    node.left = root
    return node
  }

  handler(root, v, d - 1)
  return root
};

function handler(node, v, d) {
  if (d === 1) {
    let nL = new TreeNode(v),
        nR = new TreeNode(v);
    nL.left = node.left
    nR.right = node.right
    node.left = nL
    node.right = nR
    return
  }

  if (node.left) handler(node.left, v, d - 1)
  if (node.right) handler(node.right, v, d - 1)
}
```

640. 求解方程

求解一个给定的方程，将x以字符串"x=#value"的形式返回。该方程仅包含'+'，' - '操作，变量 x 和其对应系数。

如果方程没有解，请返回“No solution”。

如果方程有无限解，则返回“Infinite solutions”。

如果方程中只有一个解，要保证返回值 x 是一个整数。

示例 1：

```
输入: "x+5-3+x=6+x-2"
输出: "x=2"
```

> 思路：将含x的移到左边，不含的移到右边，求出左右两边的和后相除就可以了

```javascript
/**
 * @param {string} equation
 * @return {string}
 */
var solveEquation = function(equation) {
  // 首先将 减 变为 加一个负数
  let str = ''
  for (let s of equation) {
    if (s === '-') str += '+'
    str += s
  }
  let a1 = str.split('='), right = [], left = []
  for (let val of a1[0].split('+')) {
    if (val[val.length - 1] === 'x') {
      if (val === 'x') left.push(1)
      else if (val === '-x') left.push(-1)
      else left.push(+val.slice(0, val.length - 1))
    } else right.push(-+val)
  }
  for (let val of a1[1].split('+')) {
    if (val[val.length - 1] === 'x') {
      if (val === 'x') left.push(-1)
      else if (val === '-x') left.push(1)
      else left.push(-+val.slice(0, val.length - 1))
    } else right.push(+val)
  }
  let l = 0, r = 0
  for (let val of left) l += val
  for (let val of right) r += val
  if (l === 0) {
    if (r === 0) return 'Infinite solutions'
    return 'No solution'
  }
  return `x=${r/l}`
};
```

## 646. 最长数对链

给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。

给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

示例 :

```
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]
```

> 思路：dp，记录当前数对的最大长度：向前寻找第一个小于当前的数对

```javascript
/**
 * @param {number[][]} pairs
 * @return {number}
 */
var findLongestChain = function(pairs) {
  let len = pairs.length
  if (len <= 1) return len
  pairs = pairs.sort((a, b) => a[0] - b[0])
  let dp = [1]
  for (let i = 1; i < len; i++) {
    let a = pairs[i][0]
    for (let j = i - 1; j >= 0; j--) {
      if (pairs[j][1] < a) {
        dp[i] = dp[j]
        break
      }
    }
    dp[i] = (dp[i] || 0) + 1
  }

  return Math.max(...dp)
};
```

## 662. 二叉树的最大宽度

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

示例 1:

```
输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
```

> 思路：记录pos，其左子树为上一层的二倍 2n，其右子树为 2n+1

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var widthOfBinaryTree = function(root) {
  if (root === null) return 0
  let queue = [root], pos = [1],
      max = 1, num = 1;
  while (queue.length > 0) {
    let tmpNum = 0
    while(num-- > 0) {
      let node = queue.shift(),
          idx = pos.shift();
      if (node.left) {
        queue.push(node.left)
        pos.push(2 * idx)
        tmpNum++
      }
      if (node.right) {
        queue.push(node.right)
        pos.push(2 * idx + 1)
        tmpNum++
      }
    }
    num = tmpNum
    if (num > 1)
        max = Math.max(max, pos[tmpNum - 1] - pos[0] + 1)
  }

  return max
};
```

## 670. 最大交换

给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

示例 1 :

```
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
```

> 思路：从右往左记录左边的最大值的索引，然后从头遍历，如果记录的索引和当前索引不同且值也不同，则交换这两个值得位置，得出结果

```javascript
/**
 * @param {number} num
 * @return {number}
 */
var maximumSwap = function(num) {
  let numArr = String(num).split(""), len = numArr.length
  if (len === 1) return num
  let tmpMax = len - 1, tmpArr = []
  tmpArr[len - 1] = tmpMax
  for (let i = len - 2; i >= 0; i--) {
    if (numArr[tmpMax] < numArr[i]) tmpMax = i
    tmpArr[i] = tmpMax
  }

  for (let i = 0; i < len; i++) {
    if (tmpArr[i] !== i && numArr[i] !== numArr[tmpArr[i]]) {
      let t = numArr[i]
      numArr[i] = numArr[tmpArr[i]]
      numArr[tmpArr[i]] = t
      break
    }
  }

  return +numArr.join("")
};
```
