## 92. 反转链表 II

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

Example:

```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

> 记录起始的节点和结束的节点，最后重新链接节点，缺点是定义的值比较多。另一个方法是做节点插入。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode reverseBetween(ListNode head, int m, int n) {
    if (head == null || head.next == null || m == n) return head;
    ListNode p1 = new ListNode(0), p2 = p1, start, end, tmp1 = null, tmp2 = null;
    p1.next = head;
    int idx = 0;
    while(++idx < m) p1 = p1.next;
    start = p1;
    end = p1.next;
    while(true) {
      tmp2 = p1.next;
      p1.next = tmp1;
      tmp1 = p1;
      if (idx++ == n + 1) {
        end.next = tmp2;
        start.next = tmp1;
        break;
      }
      p1 = tmp2;
    }
    return p2.next;
  }
}
```

## 93. 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

示例:

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

> 思路: ip 分为4段，最长位数为3位，且小于等于 255，如果每位长度大于1，则不会以0开头

```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  let result = [];
  handler(s, result, [], 0, 0)
  return result;
};

function handler(s, result, tmp, idx, curr) {
  if (curr === 4) {
    if (idx === s.length) result.push(tmp.join("."))
    return
  }

  let n = ""
  for (let i = 0; idx + i < s.length && i < 3; i++) {
    let t = [...tmp];
    n += s[idx + i]
    if (Number(n) > 255) break;
    t.push(n)
    handler(s, result, t, idx + i + 1, curr + 1)
    if (n === "0") break;
  }
}
```

## 94. 二叉树的中序遍历

给定一个二叉树，返回它的中序 遍历。

示例:

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

> 思路：先序、中序、后序遍历都是以遍历的中间节点的顺序决定的，先序：中左右，中序：左中右，后序：左右中。
> 中序就是将左子树一直压入栈，然后出栈输出值，再遍历当前右子树的值。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 第一种方法：迭代
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result = [];
    let stack = [];
    while(root !== null || stack.length > 0) {
      while (root !== null) {
        stack.push(root)
        root = root.left
      }
      root = stack.pop()
      result.push(root.val)
      root = root.right
    }
  return result;
};

/**
 * 第二种方法：递归
 * @param {TreeNode} root
 * @return {number[]}
*/
var inorderTraversal = function(root) {
  let result = [];
  handler(root, result)
  return result
}
function handler(root, result) {
  if (root === null) return;
  
  handler(root.left, result)
  result.push(root.val);
  handler(root.right, result)
}
```