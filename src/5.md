## 92. 反转链表 II

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

Example:

```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

> 记录起始的节点和结束的节点，最后重新链接节点，缺点是定义的值比较多。另一个方法是做节点插入。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode reverseBetween(ListNode head, int m, int n) {
    if (head == null || head.next == null || m == n) return head;
    ListNode p1 = new ListNode(0), p2 = p1, start, end, tmp1 = null, tmp2 = null;
    p1.next = head;
    int idx = 0;
    while(++idx < m) p1 = p1.next;
    start = p1;
    end = p1.next;
    while(true) {
      tmp2 = p1.next;
      p1.next = tmp1;
      tmp1 = p1;
      if (idx++ == n + 1) {
        end.next = tmp2;
        start.next = tmp1;
        break;
      }
      p1 = tmp2;
    }
    return p2.next;
  }
}
```

## 93. 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

示例:

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

> 思路: ip 分为4段，最长位数为3位，且小于等于 255，如果每位长度大于1，则不会以0开头

```javascript
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  let result = [];
  handler(s, result, [], 0, 0)
  return result;
};

function handler(s, result, tmp, idx, curr) {
  if (curr === 4) {
    if (idx === s.length) result.push(tmp.join("."))
    return
  }

  let n = ""
  for (let i = 0; idx + i < s.length && i < 3; i++) {
    let t = [...tmp];
    n += s[idx + i]
    if (Number(n) > 255) break;
    t.push(n)
    handler(s, result, t, idx + i + 1, curr + 1)
    if (n === "0") break;
  }
}
```

## 94. 二叉树的中序遍历

给定一个二叉树，返回它的中序 遍历。

示例:

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

> 思路：先序、中序、后序遍历都是以遍历的中间节点的顺序决定的，先序：中左右，中序：左中右，后序：左右中。
> 中序就是将左子树一直压入栈，然后出栈输出值，再遍历当前右子树的值。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * 第一种方法：迭代
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result = [];
    let stack = [];
    while(root !== null || stack.length > 0) {
      while (root !== null) {
        stack.push(root)
        root = root.left
      }
      root = stack.pop()
      result.push(root.val)
      root = root.right
    }
  return result;
};

/**
 * 第二种方法：递归
 * @param {TreeNode} root
 * @return {number[]}
*/
var inorderTraversal = function(root) {
  let result = [];
  handler(root, result)
  return result
}
function handler(root, result) {
  if (root === null) return;
  
  handler(root.left, result)
  result.push(root.val);
  handler(root.right, result)
}
```

## 95. 不同的二叉搜索树 II

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

```
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

> 思路：
> 第一种方法：递归，二叉搜索树的右值大于左值，所以肯定是以 [left, n-1] [n+1, right] 区间为左右分段
> 第二种：动态规划，由于是二叉搜索树，所以只需要一直在其右节点插入，原来的右节点作为其左节点。

```java
/**
 * 第一种方法
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public List<TreeNode> generateTrees(int n) {
    List<TreeNode> result = new ArrayList<>();
    return n < 1 ? result : handler(1, n);
  }
  private List<TreeNode> handler(int start, int end) {
    List<TreeNode> res = new ArrayList<>();
    if (start > end) {
      res.add(null);
      return res;
    }
    for (int i = start; i <= end; i++) {
      List<TreeNode> left = handler(start, i - 1);
      List<TreeNode> right = handler(i + 1, end);
      for (TreeNode l : left) {
        for (TreeNode r : right) {
          TreeNode node = new TreeNode(i);
          node.left = l;
          node.right = r;
          res.add(node);
        }
      }
    }
    return res;
  }
}

/**
 * 第二种方法
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public List<TreeNode> generateTrees(int n) {
    List<TreeNode> result = new LinkedList<>();
    if (n < 1) return result;
    
    result.add(new TreeNode(1));

    for (int i = 2; i <= n; i++) {
      List<TreeNode> resultTmp = new LinkedList<>();
      for (TreeNode x : result) {
        TreeNode r = new TreeNode(i);
        r.left = x;
        resultTmp.add(r);
        TreeNode t1 = treeCopy(x), t2 = t1, r1 = new TreeNode(i);
        while (t2 != null) {
          TreeNode t3 = t2.right;
          t2.right = r1;
          r1.left = t3;
          resultTmp.add(treeCopy(t1));
          t2.right = t3;
          r1.left = null;
          t2 = t2.right;
        }
      }
      result = resultTmp;
    }
    return result;
  }

  private TreeNode treeCopy(TreeNode root) {
    if (root == null) return null;
    TreeNode tmp = new TreeNode(root.val);
    tmp.left = treeCopy(root.left);
    tmp.right = treeCopy(root.right);
    return tmp;
  }
}
```

## 96. 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

> 思路：动态规划 
> 假设 G(n) 为全部的二叉搜索树，F(i, n) 是以 i 为根的二叉搜索树，那么有
> $$
> G(n) = \sum_{i = 0} ^n F(i, n)
> $$
> 在分为左右两部分后，他们的总数量则为
> $$
> F(i, n) = G(i - 1) * G(n - i)
> $$
> 结合两个式子则有
> $$
> G(n) = \sum_{i = 0} ^ n G(i - 1) * G(n - i)
> $$
> 注意边界条件：\[1,1\]

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  if (n < 1) return [];
  // 加入边界条件
  let result = [1, 1];
  for (let i = 2; i <= n; i++) {
    for (let j = 0; j <= i; j++) {
      result[i] = result[j - 1] * result[i - j] + (result[i] || 0)
    }
  }
  return result.pop()
};
```

## 98. 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例:

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

> 思路：中序遍历，记住，搜索二叉树的中序遍历一定是递增的。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  private boolean result = true;
  private Integer prev = null;
  public boolean isValidBST(TreeNode root) {
    handler(root);
    return result;
  }

  private void handler(TreeNode node) {
    if (node == null || !result) return;
    handler(node.left);
    if (prev == null || prev < node.val) prev = node.val;
    else result = false;
    handler(node.right);
  }
}
```

## 102. 二叉树的层次遍历

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:

```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

结果：

[
  [3],
  [9,20],
  [15,7]
]
```

> 思路：队列。每层计数

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let result = [];
  if (root === null) return result;

  let queue = [root];
  let num = 1;
  while(queue.length) {
    let tmpArr = [];
    let tmpNum = 0;
    while(num --) {
      let tmp = queue.shift();
      if (tmp.left){
        queue.push(tmp.left)
        tmpNum++;
      }
      if (tmp.right) {
        queue.push(tmp.right)
        tmpNum++
      }
      tmpArr.push(tmp.val)
    }
    num = tmpNum;
    result.push(tmpArr)
  }
  return result;
};
```

## 103. 二叉树的锯齿形层次遍历

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：

```
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

> 思路：总体思路同上一题，加个标志位。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    if (root != null) queue.add(root);
    boolean leftToRight = true;
    int nums = 1;
    while(!queue.isEmpty()) {
      int tmpNums = 0;
      List<Integer> tmpList = new ArrayList<>();
      while(nums-- != 0) {
        TreeNode tmpNode = queue.poll();
        if (tmpNode.left != null) {
          queue.add(tmpNode.left);
          tmpNums++;
        }
        if (tmpNode.right != null) {
          queue.add(tmpNode.right);
          tmpNums++;
        }
        if (leftToRight) tmpList.add(tmpNode.val);
        else tmpList.add(0, tmpNode.val);
      }
      nums = tmpNums;
      leftToRight = !leftToRight;
      result.add(tmpList);
    }
    return result;
  }
}
```

## 105. 从前序与中序遍历序列构造二叉树

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如:

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

> 思路：
> 前序遍历：父节点->左子树->右子树， 中序遍历：左子树->父节点->右子树
> 由前序和中序的对应关系可知，找到前序遍历父节点的值，可以把中序遍历分为左右子树
> 使用 HashMap 代替 indexof

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution  {
  private int pIdx = 0;
  private int[] preorder;
  private HashMap<Integer, Integer> hash_map = new HashMap<>();
  public TreeNode buildTree(int[] preorder, int[] inorder) {
    this.preorder = preorder;
    for (int i = 0; i < preorder.length; i++)
      hash_map.put(inorder[i], i);
    return handler(0, preorder.length - 1);
  }

  private TreeNode handler(int iStart, int iEnd) {
    if (iStart > iEnd) return null;
    int pVal = preorder[pIdx++];
    int iIdx = hash_map.get(pVal);

    TreeNode node = new TreeNode(pVal);
    node.left = handler(iStart, iIdx - 1);
    node.right = handler(iIdx + 1, iEnd);

    return node;
  }
}
```

## 106. 从中序与后序遍历序列构造二叉树

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如:

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

> 思路：
> 后序遍历：左节点->右节点->父节点
> 那么大体思路是和上一题差不多的，只不过需要从尾部开始，并先构建右子树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  HashMap<Integer, Integer> hash_map = new HashMap<>();
  private int[] postorder;
  private Integer pIdx;
  public TreeNode buildTree(int[] inorder, int[] postorder) {
    this.postorder = postorder;
    this.pIdx = inorder.length - 1;
    for (Integer i = 0; i < inorder.length; i++)
      hash_map.put(inorder[i], i);
    return handler(0, pIdx);
  }

  private TreeNode handler(Integer start, Integer end) {
    if (start > end || pIdx < 0) return null;
    Integer pVal = postorder[pIdx--];
    Integer iIdx = hash_map.get(pVal);
    
    TreeNode node = new TreeNode(pVal);
    node.right = handler(iIdx + 1, end);
    node.left = handler(start, iIdx - 1);

    return node;
  }
}
```

109. 有序链表转换二叉搜索树

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

> 思路：
> 主要思路是利用快慢指针来寻找到中间的元素；另外，在找到该中间元素后，将链表的前半段断开(置为null)，这样就能复用查找函数(骚操作……)。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  public TreeNode sortedListToBST(ListNode head) {
    return handler(head);
  }

  private TreeNode handler(ListNode head) {
    if (head == null) return null;
    ListNode mid = midEleNode(head);
    TreeNode node = new TreeNode(mid.val);

    if (head == mid) return node;

    node.left = handler(head);
    node.right = handler(mid.next);
    return node;
  }

  private ListNode midEleNode(ListNode head) {
    ListNode fP = head, sP = head, pP = null;
    while(fP != null && fP.next != null) {
      pP = sP;
      sP = sP.next;
      fP = fP.next.next;
    }

    // 切断链表
    if (pP != null) pP.next = null;
    return sP;
  }
}
```

## 113. 路径总和 II

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

> 思路：dfs + 回溯

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  private List<List<Integer>> result = new ArrayList<>();
  public List<List<Integer>> pathSum(TreeNode root, int sum) {
    handler(root, new ArrayList<Integer>(), sum);
    return result;
  }

  private void handler(TreeNode node, List<Integer> tmp, int target) {
    if (node == null) return;
    tmp.add(node.val);
    target = target - node.val;
    if (node.left == null && node.right == null) {
      if (target == 0)
        result.add(new ArrayList<>(tmp));
    }

    if (node.left != null) handler(node.left, tmp, target);
    if (node.right != null) handler(node.right, tmp, target);
    tmp.remove(tmp.size() - 1);
  }
}
```

## 114. 二叉树展开为链表

给定一个二叉树，原地将它展开为链表。


例如:

```
给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

> 思路：一个耍心眼的后序遍历，右子树->左子树->父节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  private TreeNode prev = null;
  public void flatten(TreeNode root) {
    if (root == null) return;
    if (root.right != null) flatten(root.right);
    if (root.left != null) flatten(root.left);
    if (prev == null) prev = root;
    else {
      root.right = prev;
      root.left = null;
      prev = root;
    }
  }
}
```

## 116. 填充每个节点的下一个右侧节点指针

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

Example:

![](./static/116_sample.png)

> 思路：队列

```javascript
/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (root === null) return root;
    let a = root;
    let queue = [root];
    let num = 1;
    while (queue.length) {
      let tmpNum = 0;
      let prevNode = null;
      while (num--) {
        let tmpNode = queue.shift();
        if (prevNode != null) prevNode.next = tmpNode
        prevNode = tmpNode;

        if (tmpNode.left){
          queue.push(tmpNode.left);
          tmpNum++;
        }
        if (tmpNode.right) {
          queue.push(tmpNode.right);
          tmpNum++;
        }
      }
      num = tmpNum;
    }
    return a;
};
```

## 117. 填充每个节点的下一个右侧节点指针 II

给定一个二叉树

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

Example：

![](./static/117_sample.png)

> 思路：队列

```javascript
/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (root === null) return root;
    let t = root;
    let queue = [root];
    let num = 1;
    while (queue.length > 0) {
      let tmpNum = 0;
      let prevNode = null;
      while (num--) {
        let tmpNode = queue.shift();
        if (prevNode != null) prevNode.next = tmpNode
        prevNode = tmpNode;

        if (tmpNode.left){
          queue.push(tmpNode.left);
          tmpNum++;
        }
        if (tmpNode.right) {
          queue.push(tmpNode.right);
          tmpNum++;
        }
      }
      num = tmpNum;
    }
    return t;
};
```

## 120. 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

> 思路：动态规划，只不过是从倒数第二行开始

```javascript
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
  for (let i = triangle.length - 2; i >= 0; i--) {
    let curr = triangle[i];
    let prev = triangle[i + 1];
    for (let j = 0; j < curr.length; j++) {
      curr[j] += Math.min(prev[j], prev[j + 1])
    }
  }
  return triangle[0][0]
};
```

## 127. 单词接龙

给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：

每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
说明:

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

示例:

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

> 思路：bfs 宽度优先搜索

```javascript
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  if (!wordList.includes(endWord)) return 0;
  let startQueue = [],visited = {};
  startQueue.push({
    word: beginWord,
    depth: 1,
  });
  while(startQueue.length) {
    let t = startQueue.shift();
    for (let val of wordList) {
      if (diffWord(t.word, val) && !visited[val]) {
        if (val === endWord) return t.depth + 1;
        visited[val] = true;
        startQueue.push({
          word: val,
          depth: t.depth + 1
        })
      }
    }
  }
  return 0;
};

function diffWord(word1, word2) {
  let diff = 0;
  for (let i = 0; i < word1.length; i++) {
    if (word1[i] !== word2[i] && ++diff > 1)
      return false;
  }
  return true;
}
```

## 129. 求根到叶子节点数字之和

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

> 思路：递归……

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  private int sum = 0;
  public int sumNumbers(TreeNode root) {
    handler(root, 0);
    return sum;
  }
  private void handler(TreeNode node, int tmp) {
    if (node == null) return;
    int val = tmp * 10 + node.val;
    if (node.left == null && node.right == null)
      sum += val;

    if (node.left != null)
      handler(node.left, val);
    if (node.right != null)
      handler(node.right, val);
  }
}
```

## 130. 被围绕的区域

给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

示例:

```
X X X X
X O O X
X X O X
X O X X
运行你的函数后，矩阵变为：

X X X X
X X X X
X X X X
X O X X
解释:

被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

> 思路：可以从最边上查找 O，找到后，进行深度优先搜索相邻的 O，并将其置为 "-", 最后，将 O 改为 X，- 改为 O

```javascript
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  if (board == null || board.length < 1) return;
  let row = board.length,
      col = board[0].length;
  for (let i = 0; i < row; i++) {
    dfs(i, 0);
    dfs(i, col - 1);
  }
  for (let j = 0; j < col; j++) {
    dfs(0, j);
    dfs(row - 1, j);
  }

  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (board[i][j] === "O")
        board[i][j] = "X"
      else if (board[i][j] === "-")
        board[i][j] = "O"
    }
  }

  function dfs(i, j) {
    if (i < 0 || j < 0 || i >= row || j >= col)
      return;
    if (board[i][j] === "O") {
      board[i][j] = "-"
      dfs(i - 1, j);
      dfs(i + 1, j);
      dfs(i, j - 1);
      dfs(i, j + 1);
    }
  }
};
```

## 131. 分割回文串

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例:

```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

> 思路：截取前n个判断是否为回文，然后在判断剩下的前m个是否为回文。

```javascript
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  let result = []
  handler(s, s.length, result, [], 0)
  return result;
};

function handler(s, len, result, tmp, curr) {
  if (len == curr) {
    result.push([...tmp]);
    return;
  };
  for (let i = 1; i <= len; i++) {
    let currStr = s.substr(curr, i)
    if (isPartition(currStr)) {
      tmp.push(currStr);
      handler(s, len, result, tmp, curr + i, len)
      tmp.pop()
    }
  }
}

function isPartition(s) {
  if (s === "") return false;
  let i = 0, j = s.length - 1;
  while(i < j)
    if (s[i++] !== s[j--])
      return false;
  return true;
}
```

## 134. 加油站

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

示例 1:

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

```javascript
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  let len = gas.length;
  for (let i = 0; i < len; i++)
    if (gas[i] >= cost[i])
      if (handler(gas, cost, i))
        return i;
  return -1;
};

function handler(gas, cost, idx) {
  let has = 0;
  for (let i = 0, len = gas.length; i < len; i++) {
    has = gas[idx] + has - cost[idx]
    if (has < 0) return false;
    if (++idx >= len) idx = 0;
  }
  return true;
}
```

## 138. 复制带随机指针的链表

给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的深拷贝。

示例：

![](./static/1470150906153-2yxeznm.png)

```
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

解释：
节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。
```

```javascript
/**
 * // Definition for a Node.
 * function Node(val,next,random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */
/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
  let tmp = {};
  let newHead = new Node(null), tmpNewHead = newHead;

  while (head !== null) {
    let t = head.val;
    let r = head.random;
    if (!tmp[t]) {
      tmpNewHead.next = new Node(t);
      tmp[t] = tmpNewHead.next;
      tmpNewHead = tmpNewHead.next;
    } else {
      tmpNewHead.next = tmp[t];
      tmpNewHead = tmp[t];
    }
    if (r) {
      if (!tmp[r.val]) {
        tmpNewHead.random = new Node(r.val);
        tmp[r.val] = tmpNewHead.random;
      } else {
        tmpNewHead.random = tmp[r.val]
      }
    }
    head = head.next;
  }

  return newHead.next;
};
```

## 139. 单词拆分

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

示例 1：

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

> 思路：动态规划，将单词分为左右两部分，如果两部分都符合，那么结果肯定也符合。例如 catsanddog 可以被分割为 catsand 和 dog，catsand 可以被拆分为 cats 和 and，这样如果前半部分满足后半部分也满足，则整个字符串也满足。

```javascript
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let t = [true];
  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (t[j] && wordDict.includes(s.substring(j, i))) {
        t[i] = true;
        break;
      }
    }
  }
  return !!t[s.length]
};
```

## 142. 环形链表 II

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。


示例 1：

```

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

![](./static/circularlinkedlist.png)

> 思路：快慢指针判断是否有环。设 环前长度为 a, 环内已走为 b, 快慢指针相交于环内,即剩余的为 c，因为快指针是慢指针的2倍，那么有 2(a+b) = a + b + c + b，即 a = c。所以在走 a 步即为入口

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if (head === null) return null;
    // 判断是否有环
    let p1 = head, p2 = head;
    let hasCircle = false;
    while(p2.next != null && p2.next.next != null) {
      p1 = p1.next;
      p2 = p2.next.next;
      if (p1 === p2) {
        hasCircle = true;
        break;
      }
    }

    if (hasCircle) {
      p1 = head;
      while (p1 !== p2) {
        p1 = p1.next;
        p2 = p2.next;
      }
      return p2;
    } else {
      return null;
    }
};
```

## 143. 重排链表

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

```
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
```

> 思路：
> 方法一：双端队列，莫得灵魂/(ㄒoㄒ)/~~
> 方法二：分为两段，翻转后一段，然后交叉插入。

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * 方法一
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function(head) {
  let queue  = [];
  let tHead = head;
  while(tHead !== null) {
    queue.push(tHead);
    tHead = tHead.next;
  }

  let s = 0;
  let t = null;
  while(queue.length > 0) {
    if (s++ % 2 === 0) {
      if (t === null) t = queue.shift()
      else {
        t.next = queue.shift();
        t = t.next
      }
    } else {
      t.next = queue.pop()
      t = t.next;
    }
  }
  if (t !== null) t.next = null;
  return head;
};

/**
 * 方法二
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function(head) {
  if (head === null) return head;

  let p1 = head, p2 = head;
  while(p2 !== null && p2.next !== null) {
    p1 = p1.next;
    p2 = p2.next.next;
  }

  let p3 = reverse(p1.next);
  p1.next = null;
  p2 = head;
  while(p3 !== null) {
    let tmp2 = p2.next;
    p2.next = p3;
    let tmp1 = p3.next;
    p3.next = tmp2;
    p3 = tmp1;
    p2 = tmp2;
  }
};

function reverse(head) {
  let p1 = head, p2 = null, tmp = null;
  while (p1 !== null) {
    tmp = p1.next;
    p1.next = p2;
    p2 = p1;
    p1 = tmp;
  }
  return p2;
}
```

## 144. 二叉树的前序遍历

给定一个二叉树，返回它的 前序 遍历。

示例:

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

> 思路：递归实际上也是栈的一种，所以使用栈来实现递归，输出当前节点的值，将左子树一直插入，最后一个一个推出，如果有右子树，则输出右子树的值，并压入栈。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
  let t = [], r = [];
  while(root !== null || t.length > 0) {
    while(root !== null) {
      r.push(root.val);
      t.push(root);
      root = root.left;
    }
    let n = t.pop();
    if (n.right) root = n.right;
  }
  return r;
};
```

## 146. LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例:

```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

> 思路：双向链表 + hashMap

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.capacity = capacity;
  this.map = {};
  this.currCap = 0;
  this.head = new doubleLinked(null);
  this.tail = new doubleLinked(null);
  this.head.next = this.tail;
  this.tail.prev = this.head;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  let node = this.map[key];
  if (node === undefined) return -1;
  node.prev.next = node.next;
  node.next.prev = node.prev;
  addTail(this.tail, node);
  return node.val.value;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    this.map[key].val.value = value;
    this.get(key)
    return;
  }
  if (this.capacity > this.currCap) {
    this.currCap++;
  } else {
    delete this.map[this.head.next.val.key]
    removeHead(this.head)
  }
  let node = new doubleLinked({key, value})
  this.map[key] = node;
  addTail(this.tail, node)
};

function doubleLinked(val) {
  this.val = val;
  this.next = null;
  this.prev = null;
}

function addTail(tail, node) {
  let tmp = tail.prev;
  tmp.next = node;
  node.prev = tmp;
  node.next = tail;
  tail.prev = node;
}

function removeHead(head) {
  head.next = head.next.next;
  head.next.prev = head;
}

/** 
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

## 147. 对链表进行插入排序

对链表进行插入排序。

![](./static/Insertion-sort-example-300px.gif)

插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

> 思路：插入排序。

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertionSortList = function(head) {
  let p = head, q = head;
  while(p !== null && p.next !== null) {
    let t = p.next;
    if (t.val < p.val) {
      p.next = t.next;
      q = head;
      if (t.val <= q.val) {
        t.next = q;
        head = t;
      } else {
        while (q.next !== null) {
          if (t.val <= q.next.val) {
            let tmp = q.next;
            q.next = t;
            t.next = tmp;
            break;
          }
          q = q.next;
        }
      }
    } else {
      p = p.next;
    }
  }
  return head;
};
```

## 148. 排序链表

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

```
输入: 4->2->1->3
输出: 1->2->3->4
```

> 思路：因为是O(nlogn) 的时间复杂度，所以为归并排序，如果是数组的话，需要开辟新的空间，空间复杂度为 O(n)，但是由于是链表，所有的操作都是在原链表上进行的，所以空间复杂度为 O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
  public ListNode sortList(ListNode head) {
    return mergeSort(head);
  }
  // 用于拆分
  private ListNode mergeSort(ListNode head) {
    if (head == null || head.next == null)
      return head;
    ListNode p1 = head, p2 = head, pre = null;
    while(p2 != null && p2.next != null) {
      pre = p1;
      p1 = p1.next;
      p2 = p2.next.next;
    }
    if (pre != null) pre.next = null;
    ListNode l = mergeSort(head);
    ListNode r = mergeSort(p1);
    return merge(l, r);
  }
  // 用于合并 
  private ListNode merge(ListNode l, ListNode r) {
    ListNode fHead = new ListNode(0), tmpHead = fHead;
    while(l != null && r != null) {
      if (l.val > r.val) {
        tmpHead.next = r;
        r = r.next;
      } else {
        tmpHead.next = l;
        l = l.next;
      }
      tmpHead = tmpHead.next;
    }
    if (l == null) {
      tmpHead.next = r;
    } else {
      tmpHead.next = l;
    }

    return fHead.next;
  }
}
```

## 150. 逆波兰表达式求值

根据逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例：

```
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9
```

> 思路：栈

```javascript
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  let queue = [];
  for (let i = 0; i < tokens.length; i++) {
    if (/^[\+\-\*\/]$/.test(tokens[i])) {
      let a = Number(queue.pop()), b = Number(queue.pop())
      switch(tokens[i]) {
        case "+": 
          queue.push(b + a)
          break;
        case "-":
          queue.push(b - a)
          break;
        case "*":
          queue.push(b * a)
          break;
        case "/":
          queue.push(b / a | 0)
          break;
      }
    } else {
      queue.push(tokens[i]);
    }
  }
  return queue.pop()
};
```

## 151. 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

```
输入: "the sky is blue"
输出: "blue is sky the"
```

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  let result = "", tmpS = "";
  for (let i = 0; i< s.length; i++) {
    if (s[i] === " ") {
      if (tmpS.length > 0) {
        if (result.length === 0)
          result = tmpS + result;
        else result = tmpS + " " + result;
        tmpS = ""
      }
    } else {
      tmpS += s[i]
    }
  }
  if (tmpS.length > 0) {
    if (result.length === 0)
      result = tmpS + result;
    else
      result = tmpS + " " + result;
  }
  return result;
};
```

## 152. 乘积最大子序列

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

> 思路：动态规划
> 找出最大值和最小值，如果遇到负数，则最大值和最小值互换

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let imax = 1, imin = 1, max = -Math.pow(2, 31);
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) {
      let tmp = imax;
      imax = imin;
      imin = tmp;
    }
    imax = Math.max(imax * nums[i], nums[i]);
    imin = Math.min(imin * nums[i], nums[i]);
    
    max = Math.max(imax, max);
  }
  return max;
};
```

## 153. 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:

```
输入: [3,4,5,1,2]
输出: 1
```

> 思路：二分法。二分法并不是需要对两端做+1/-1,有时候只需要向一方逼近就行。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  let l = 0, r = nums.length - 1;
  if (nums[l] <= nums[r])
    return nums[0];
  while(l < r) {
    let mid = (l + r) / 2 | 0;
    if (nums[mid] < nums[r]) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[l]
};
```